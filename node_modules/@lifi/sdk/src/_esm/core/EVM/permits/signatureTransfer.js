import { hashTypedData } from 'viem';
import { invariant } from '../../../utils/invariant.js';
import { MaxSigDeadline, MaxSignatureTransferAmount, MaxUnorderedNonce, } from './constants.js';
import { permit2Domain } from './domain.js';
const TOKEN_PERMISSIONS = [
    { name: 'token', type: 'address' },
    { name: 'amount', type: 'uint256' },
];
const PERMIT_TRANSFER_FROM_TYPES = {
    TokenPermissions: TOKEN_PERMISSIONS,
    PermitTransferFrom: [
        { name: 'permitted', type: 'TokenPermissions' },
        { name: 'spender', type: 'address' },
        { name: 'nonce', type: 'uint256' },
        { name: 'deadline', type: 'uint256' },
    ],
};
const PERMIT_BATCH_TRANSFER_FROM_TYPES = {
    TokenPermissions: TOKEN_PERMISSIONS,
    PermitBatchTransferFrom: [
        { name: 'permitted', type: 'TokenPermissions[]' },
        { name: 'spender', type: 'address' },
        { name: 'nonce', type: 'uint256' },
        { name: 'deadline', type: 'uint256' },
    ],
};
function isPermitTransferFrom(permit) {
    return !Array.isArray(permit.permitted);
}
export function getPermitTransferData(permit, permit2Address, chainId, witness) {
    invariant(MaxSigDeadline >= permit.deadline, 'SIG_DEADLINE_OUT_OF_RANGE');
    invariant(MaxUnorderedNonce >= permit.nonce, 'NONCE_OUT_OF_RANGE');
    const domain = permit2Domain(permit2Address, chainId);
    validateTokenPermissions(permit.permitted);
    const types = witness
        ? {
            TokenPermissions: TOKEN_PERMISSIONS,
            ...witness.witnessType,
            PermitWitnessTransferFrom: [
                { name: 'permitted', type: 'TokenPermissions' },
                { name: 'spender', type: 'address' },
                { name: 'nonce', type: 'uint256' },
                { name: 'deadline', type: 'uint256' },
                { name: 'witness', type: witness.witnessTypeName },
            ],
        }
        : PERMIT_TRANSFER_FROM_TYPES;
    const message = witness
        ? Object.assign(permit, { witness: witness.witness })
        : permit;
    return {
        domain,
        types,
        message,
    };
}
export function getPermitBatchTransferData(permit, permit2Address, chainId, witness) {
    invariant(MaxSigDeadline >= permit.deadline, 'SIG_DEADLINE_OUT_OF_RANGE');
    invariant(MaxUnorderedNonce >= permit.nonce, 'NONCE_OUT_OF_RANGE');
    const domain = permit2Domain(permit2Address, chainId);
    permit.permitted.forEach(validateTokenPermissions);
    const types = witness
        ? {
            ...witness.witnessType,
            TokenPermissions: TOKEN_PERMISSIONS,
            PermitBatchWitnessTransferFrom: [
                { name: 'permitted', type: 'TokenPermissions[]' },
                { name: 'spender', type: 'address' },
                { name: 'nonce', type: 'uint256' },
                { name: 'deadline', type: 'uint256' },
                { name: 'witness', type: witness.witnessTypeName },
            ],
        }
        : PERMIT_BATCH_TRANSFER_FROM_TYPES;
    const message = witness
        ? Object.assign(permit, { witness: witness.witness })
        : permit;
    return {
        domain,
        types,
        message,
    };
}
export function getPermitData(permit, permit2Address, chainId, witness) {
    if (isPermitTransferFrom(permit)) {
        return getPermitTransferData(permit, permit2Address, chainId, witness);
    }
    return getPermitBatchTransferData(permit, permit2Address, chainId, witness);
}
export function hash(permit, permit2Address, chainId, witness) {
    if (isPermitTransferFrom(permit)) {
        const { domain, types, message } = getPermitTransferData(permit, permit2Address, chainId, witness);
        return hashTypedData({
            domain,
            types,
            primaryType: witness ? 'PermitWitnessTransferFrom' : 'PermitTransferFrom',
            message: {
                ...message,
            },
        });
    }
    const { domain, types, message } = getPermitBatchTransferData(permit, permit2Address, chainId, witness);
    return hashTypedData({
        domain,
        types,
        primaryType: witness
            ? 'PermitBatchWitnessTransferFrom'
            : 'PermitBatchTransferFrom',
        message: { ...message },
    });
}
function validateTokenPermissions(permissions) {
    invariant(MaxSignatureTransferAmount >= permissions.amount, 'AMOUNT_OUT_OF_RANGE');
}
//# sourceMappingURL=signatureTransfer.js.map