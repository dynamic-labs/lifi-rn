"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.waitForTransactionStatus = waitForTransactionStatus;
const errors_js_1 = require("../errors/errors.js");
const api_js_1 = require("../services/api.js");
const waitForResult_js_1 = require("../utils/waitForResult.js");
const processMessages_js_1 = require("./processMessages.js");
const TRANSACTION_HASH_OBSERVERS = {};
async function waitForTransactionStatus(statusManager, txHash, step, processType, interval = 5_000) {
    const _getStatus = () => {
        return (0, api_js_1.getStatus)({
            fromChain: step.action.fromChainId,
            fromAddress: step.action.fromAddress,
            toChain: step.action.toChainId,
            txHash,
            ...(step.tool !== 'custom' && { bridge: step.tool }),
        })
            .then((statusResponse) => {
            switch (statusResponse.status) {
                case 'DONE':
                    return statusResponse;
                case 'PENDING':
                    statusManager?.updateProcess(step, processType, 'PENDING', {
                        substatus: statusResponse.substatus,
                        substatusMessage: statusResponse.substatusMessage ||
                            (0, processMessages_js_1.getSubstatusMessage)(statusResponse.status, statusResponse.substatus),
                        txLink: statusResponse.bridgeExplorerLink,
                    });
                    return undefined;
                case 'NOT_FOUND':
                    return undefined;
                default:
                    return Promise.reject();
            }
        })
            .catch((e) => {
            if (process.env.NODE_ENV === 'development') {
                console.debug('Fetching status from backend failed.', e);
            }
            return undefined;
        });
    };
    let status = TRANSACTION_HASH_OBSERVERS[txHash];
    if (!status) {
        status = (0, waitForResult_js_1.waitForResult)(_getStatus, interval);
        TRANSACTION_HASH_OBSERVERS[txHash] = status;
    }
    const resolvedStatus = await status;
    if (!('receiving' in resolvedStatus)) {
        throw new errors_js_1.ServerError("Status doesn't contain destination chain information.");
    }
    return resolvedStatus;
}
//# sourceMappingURL=waitForTransactionStatus.js.map