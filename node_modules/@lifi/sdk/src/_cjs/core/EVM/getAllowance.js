"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getTokenAllowanceMulticall = exports.getTokenAllowance = exports.getAllowanceMulticall = exports.getAllowance = void 0;
const actions_1 = require("viem/actions");
const isZeroAddress_js_1 = require("../../utils/isZeroAddress.js");
const abi_js_1 = require("./abi.js");
const getActionWithFallback_js_1 = require("./getActionWithFallback.js");
const publicClient_js_1 = require("./publicClient.js");
const utils_js_1 = require("./utils.js");
const getAllowance = async (client, tokenAddress, ownerAddress, spenderAddress) => {
    try {
        const approved = await (0, getActionWithFallback_js_1.getActionWithFallback)(client, actions_1.readContract, 'readContract', {
            address: tokenAddress,
            abi: abi_js_1.allowanceAbi,
            functionName: 'allowance',
            args: [ownerAddress, spenderAddress],
        });
        return approved;
    }
    catch (_e) {
        return 0n;
    }
};
exports.getAllowance = getAllowance;
const getAllowanceMulticall = async (client, chainId, tokens, ownerAddress) => {
    if (!tokens.length) {
        return [];
    }
    const multicallAddress = await (0, utils_js_1.getMulticallAddress)(chainId);
    if (!multicallAddress) {
        throw new Error(`No multicall address configured for chainId ${chainId}.`);
    }
    const contracts = tokens.map((token) => ({
        address: token.token.address,
        abi: abi_js_1.allowanceAbi,
        functionName: 'allowance',
        args: [ownerAddress, token.spenderAddress],
    }));
    const results = await (0, getActionWithFallback_js_1.getActionWithFallback)(client, actions_1.multicall, 'multicall', {
        contracts,
        multicallAddress: multicallAddress,
    });
    if (!results.length) {
        throw new Error(`Couldn't load allowance from chainId ${chainId} using multicall.`);
    }
    return tokens.map(({ token, spenderAddress }, i) => ({
        token,
        spenderAddress,
        allowance: results[i].result,
    }));
};
exports.getAllowanceMulticall = getAllowanceMulticall;
const getTokenAllowance = async (token, ownerAddress, spenderAddress) => {
    if ((0, isZeroAddress_js_1.isZeroAddress)(token.address)) {
        return;
    }
    const client = await (0, publicClient_js_1.getPublicClient)(token.chainId);
    const approved = await (0, exports.getAllowance)(client, token.address, ownerAddress, spenderAddress);
    return approved;
};
exports.getTokenAllowance = getTokenAllowance;
const getTokenAllowanceMulticall = async (ownerAddress, tokens) => {
    const filteredTokens = tokens.filter(({ token }) => !(0, isZeroAddress_js_1.isZeroAddress)(token.address));
    const tokenDataByChain = {};
    for (const data of filteredTokens) {
        if (!tokenDataByChain[data.token.chainId]) {
            tokenDataByChain[data.token.chainId] = [];
        }
        tokenDataByChain[data.token.chainId].push(data);
    }
    const chainKeys = Object.keys(tokenDataByChain).map(Number.parseInt);
    const allowances = (await Promise.all(chainKeys.map(async (chainId) => {
        const client = await (0, publicClient_js_1.getPublicClient)(chainId);
        return (0, exports.getAllowanceMulticall)(client, chainId, tokenDataByChain[chainId], ownerAddress);
    }))).flat();
    return allowances;
};
exports.getTokenAllowanceMulticall = getTokenAllowanceMulticall;
//# sourceMappingURL=getAllowance.js.map