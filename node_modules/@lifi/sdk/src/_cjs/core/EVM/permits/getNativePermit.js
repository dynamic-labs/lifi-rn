"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getNativePermit = exports.getContractData = void 0;
const viem_1 = require("viem");
const actions_1 = require("viem/actions");
const abi_js_1 = require("../abi.js");
const getActionWithFallback_js_1 = require("../getActionWithFallback.js");
const utils_js_1 = require("../utils.js");
const constants_js_1 = require("./constants.js");
function makeDomainSeparator({ name, version, chainId, verifyingContract, withSalt = false, }) {
    const nameHash = (0, viem_1.keccak256)((0, viem_1.toBytes)(name));
    const versionHash = (0, viem_1.keccak256)((0, viem_1.toBytes)(version));
    const encoded = withSalt
        ? (0, viem_1.encodeAbiParameters)((0, viem_1.parseAbiParameters)('bytes32, bytes32, bytes32, address, bytes32'), [
            constants_js_1.EIP712_DOMAIN_TYPEHASH_WITH_SALT,
            nameHash,
            versionHash,
            verifyingContract,
            (0, viem_1.pad)((0, viem_1.toHex)(chainId), { size: 32 }),
        ])
        : (0, viem_1.encodeAbiParameters)((0, viem_1.parseAbiParameters)('bytes32, bytes32, bytes32, uint256, address'), [
            constants_js_1.EIP712_DOMAIN_TYPEHASH,
            nameHash,
            versionHash,
            BigInt(chainId),
            verifyingContract,
        ]);
    return (0, viem_1.keccak256)(encoded);
}
function validateDomainSeparator({ name, version, chainId, verifyingContract, domainSeparator, }) {
    if (!name || !domainSeparator) {
        return {
            isValid: false,
            domain: {},
        };
    }
    for (const withSalt of [false, true]) {
        const computedDS = makeDomainSeparator({
            name,
            version,
            chainId,
            verifyingContract,
            withSalt,
        });
        if (domainSeparator.toLowerCase() === computedDS.toLowerCase()) {
            return {
                isValid: true,
                domain: withSalt
                    ? {
                        name,
                        version,
                        verifyingContract,
                        salt: (0, viem_1.pad)((0, viem_1.toHex)(chainId), { size: 32 }),
                    }
                    : {
                        name,
                        version,
                        chainId,
                        verifyingContract,
                    },
            };
        }
    }
    return {
        isValid: false,
        domain: {},
    };
}
const getContractData = async (client, chainId, tokenAddress) => {
    try {
        const multicallAddress = await (0, utils_js_1.getMulticallAddress)(chainId);
        const contractCalls = [
            {
                address: tokenAddress,
                abi: abi_js_1.eip2612Abi,
                functionName: 'name',
            },
            {
                address: tokenAddress,
                abi: abi_js_1.eip2612Abi,
                functionName: 'DOMAIN_SEPARATOR',
            },
            {
                address: tokenAddress,
                abi: abi_js_1.eip2612Abi,
                functionName: 'PERMIT_TYPEHASH',
            },
            {
                address: tokenAddress,
                abi: abi_js_1.eip2612Abi,
                functionName: 'nonces',
                args: [client.account.address],
            },
            {
                address: tokenAddress,
                abi: abi_js_1.eip2612Abi,
                functionName: 'version',
            },
        ];
        if (multicallAddress) {
            try {
                const [nameResult, domainSeparatorResult, permitTypehashResult, noncesResult, versionResult,] = await (0, getActionWithFallback_js_1.getActionWithFallback)(client, actions_1.multicall, 'multicall', {
                    contracts: contractCalls,
                    multicallAddress,
                });
                if (nameResult.status !== 'success' ||
                    domainSeparatorResult.status !== 'success' ||
                    noncesResult.status !== 'success' ||
                    !nameResult.result ||
                    !domainSeparatorResult.result ||
                    noncesResult.result === undefined) {
                    throw new Error('Multicall failed');
                }
                return {
                    name: nameResult.result,
                    domainSeparator: domainSeparatorResult.result,
                    permitTypehash: permitTypehashResult.result,
                    nonce: noncesResult.result,
                    version: versionResult.result ?? '1',
                };
            }
            catch {
            }
        }
        const [nameResult, domainSeparatorResult, permitTypehashResult, noncesResult, versionResult,] = (await Promise.allSettled(contractCalls.map((call) => (0, getActionWithFallback_js_1.getActionWithFallback)(client, actions_1.readContract, 'readContract', call))));
        if (nameResult.status !== 'fulfilled' ||
            domainSeparatorResult.status !== 'fulfilled' ||
            noncesResult.status !== 'fulfilled') {
            return undefined;
        }
        const name = nameResult.value;
        const version = versionResult.status === 'fulfilled' ? versionResult.value : '1';
        return {
            name,
            domainSeparator: domainSeparatorResult.value,
            permitTypehash: permitTypehashResult.status === 'fulfilled'
                ? permitTypehashResult.value
                : undefined,
            nonce: noncesResult.value,
            version,
        };
    }
    catch {
        return undefined;
    }
};
exports.getContractData = getContractData;
const getNativePermit = async (client, { chainId, tokenAddress, spenderAddress, amount }) => {
    const contractData = await (0, exports.getContractData)(client, chainId, tokenAddress);
    if (!contractData) {
        return undefined;
    }
    const { name, domainSeparator, permitTypehash, nonce, version } = contractData;
    if (permitTypehash === constants_js_1.DAI_LIKE_PERMIT_TYPEHASH) {
        return undefined;
    }
    const { isValid, domain } = validateDomainSeparator({
        name,
        version,
        chainId,
        verifyingContract: tokenAddress,
        domainSeparator,
    });
    if (!isValid) {
        return undefined;
    }
    const deadline = BigInt(Math.floor(Date.now() / 1000) + 30 * 60).toString();
    const message = {
        owner: client.account.address,
        spender: spenderAddress,
        value: amount.toString(),
        nonce: nonce.toString(),
        deadline,
    };
    return {
        primaryType: 'Permit',
        domain,
        types: constants_js_1.eip2612Types,
        message,
    };
};
exports.getNativePermit = getNativePermit;
//# sourceMappingURL=getNativePermit.js.map