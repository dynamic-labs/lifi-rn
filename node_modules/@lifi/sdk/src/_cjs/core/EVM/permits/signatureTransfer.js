"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPermitTransferData = getPermitTransferData;
exports.getPermitBatchTransferData = getPermitBatchTransferData;
exports.getPermitData = getPermitData;
exports.hash = hash;
const viem_1 = require("viem");
const invariant_js_1 = require("../../../utils/invariant.js");
const constants_js_1 = require("./constants.js");
const domain_js_1 = require("./domain.js");
const TOKEN_PERMISSIONS = [
    { name: 'token', type: 'address' },
    { name: 'amount', type: 'uint256' },
];
const PERMIT_TRANSFER_FROM_TYPES = {
    TokenPermissions: TOKEN_PERMISSIONS,
    PermitTransferFrom: [
        { name: 'permitted', type: 'TokenPermissions' },
        { name: 'spender', type: 'address' },
        { name: 'nonce', type: 'uint256' },
        { name: 'deadline', type: 'uint256' },
    ],
};
const PERMIT_BATCH_TRANSFER_FROM_TYPES = {
    TokenPermissions: TOKEN_PERMISSIONS,
    PermitBatchTransferFrom: [
        { name: 'permitted', type: 'TokenPermissions[]' },
        { name: 'spender', type: 'address' },
        { name: 'nonce', type: 'uint256' },
        { name: 'deadline', type: 'uint256' },
    ],
};
function isPermitTransferFrom(permit) {
    return !Array.isArray(permit.permitted);
}
function getPermitTransferData(permit, permit2Address, chainId, witness) {
    (0, invariant_js_1.invariant)(constants_js_1.MaxSigDeadline >= permit.deadline, 'SIG_DEADLINE_OUT_OF_RANGE');
    (0, invariant_js_1.invariant)(constants_js_1.MaxUnorderedNonce >= permit.nonce, 'NONCE_OUT_OF_RANGE');
    const domain = (0, domain_js_1.permit2Domain)(permit2Address, chainId);
    validateTokenPermissions(permit.permitted);
    const types = witness
        ? {
            TokenPermissions: TOKEN_PERMISSIONS,
            ...witness.witnessType,
            PermitWitnessTransferFrom: [
                { name: 'permitted', type: 'TokenPermissions' },
                { name: 'spender', type: 'address' },
                { name: 'nonce', type: 'uint256' },
                { name: 'deadline', type: 'uint256' },
                { name: 'witness', type: witness.witnessTypeName },
            ],
        }
        : PERMIT_TRANSFER_FROM_TYPES;
    const message = witness
        ? Object.assign(permit, { witness: witness.witness })
        : permit;
    return {
        domain,
        types,
        message,
    };
}
function getPermitBatchTransferData(permit, permit2Address, chainId, witness) {
    (0, invariant_js_1.invariant)(constants_js_1.MaxSigDeadline >= permit.deadline, 'SIG_DEADLINE_OUT_OF_RANGE');
    (0, invariant_js_1.invariant)(constants_js_1.MaxUnorderedNonce >= permit.nonce, 'NONCE_OUT_OF_RANGE');
    const domain = (0, domain_js_1.permit2Domain)(permit2Address, chainId);
    permit.permitted.forEach(validateTokenPermissions);
    const types = witness
        ? {
            ...witness.witnessType,
            TokenPermissions: TOKEN_PERMISSIONS,
            PermitBatchWitnessTransferFrom: [
                { name: 'permitted', type: 'TokenPermissions[]' },
                { name: 'spender', type: 'address' },
                { name: 'nonce', type: 'uint256' },
                { name: 'deadline', type: 'uint256' },
                { name: 'witness', type: witness.witnessTypeName },
            ],
        }
        : PERMIT_BATCH_TRANSFER_FROM_TYPES;
    const message = witness
        ? Object.assign(permit, { witness: witness.witness })
        : permit;
    return {
        domain,
        types,
        message,
    };
}
function getPermitData(permit, permit2Address, chainId, witness) {
    if (isPermitTransferFrom(permit)) {
        return getPermitTransferData(permit, permit2Address, chainId, witness);
    }
    return getPermitBatchTransferData(permit, permit2Address, chainId, witness);
}
function hash(permit, permit2Address, chainId, witness) {
    if (isPermitTransferFrom(permit)) {
        const { domain, types, message } = getPermitTransferData(permit, permit2Address, chainId, witness);
        return (0, viem_1.hashTypedData)({
            domain,
            types,
            primaryType: witness ? 'PermitWitnessTransferFrom' : 'PermitTransferFrom',
            message: {
                ...message,
            },
        });
    }
    const { domain, types, message } = getPermitBatchTransferData(permit, permit2Address, chainId, witness);
    return (0, viem_1.hashTypedData)({
        domain,
        types,
        primaryType: witness
            ? 'PermitBatchWitnessTransferFrom'
            : 'PermitBatchTransferFrom',
        message: { ...message },
    });
}
function validateTokenPermissions(permissions) {
    (0, invariant_js_1.invariant)(constants_js_1.MaxSignatureTransferAmount >= permissions.amount, 'AMOUNT_OUT_OF_RANGE');
}
//# sourceMappingURL=signatureTransfer.js.map