"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveUNSAddress = void 0;
const types_1 = require("@lifi/types");
const actions_1 = require("viem/actions");
const ens_1 = require("viem/ens");
const utils_1 = require("viem/utils");
const publicClient_js_1 = require("../publicClient.js");
const constants_js_1 = require("./constants.js");
const resolveUNSAddress = async (name, chainType, chain, token) => {
    try {
        const L1Client = await (0, publicClient_js_1.getPublicClient)(types_1.ChainId.ETH);
        const L2Client = await (0, publicClient_js_1.getPublicClient)(types_1.ChainId.POL);
        const nameHash = (0, ens_1.namehash)(name);
        const keys = [];
        if (chain) {
            const family = constants_js_1.CHAIN_TYPE_FAMILY_MAP[chainType];
            const unschain = constants_js_1.CHAIN_ID_UNS_CHAIN_MAP[chain];
            if (family) {
                if (token) {
                    keys.push(`token.${family}.${unschain}.${token}.address`);
                }
                if (unschain) {
                    keys.push(`token.${family}.${unschain}.address`);
                }
                keys.push(`token.${family}.address`);
            }
        }
        const unschainType = constants_js_1.CHAIN_TYPE_UNS_CHAIN_MAP[chainType];
        keys.push(`crypto.${unschainType}.address`);
        for (const key of keys) {
            const address = (await getUnsAddress(L2Client, { name: nameHash, key })) ||
                (await getUnsAddress(L1Client, { name: nameHash, key }));
            if (address) {
                return address;
            }
        }
        return undefined;
    }
    catch {
        return undefined;
    }
};
exports.resolveUNSAddress = resolveUNSAddress;
async function getUnsAddress(client, params) {
    const { name, key } = params;
    const chainId = client.chain?.id;
    if (!chainId) {
        throw new Error('Chain ID not available');
    }
    const proxyAddress = (0, constants_js_1.getUNSProxyAddress)(chainId);
    if (!proxyAddress) {
        throw new Error(`UNS contracts are not deployed on chain ${chainId}`);
    }
    const readContractAction = (0, utils_1.getAction)(client, actions_1.readContract, 'readContract');
    const existsReadContractParameters = {
        abi: constants_js_1.UNSProxyReaderABI,
        address: proxyAddress,
        functionName: 'exists',
        args: [BigInt(name)],
    };
    const exists = await readContractAction(existsReadContractParameters);
    if (!exists) {
        return undefined;
    }
    const readContractParameters = {
        abi: constants_js_1.UNSProxyReaderABI,
        address: proxyAddress,
        functionName: 'getData',
        args: [[key], BigInt(name)],
    };
    const res = await readContractAction(readContractParameters);
    const [, , addresses] = res;
    const address = addresses[0];
    if (address === '0x' ||
        address === '' ||
        (0, utils_1.trim)(address) === '0x00') {
        return undefined;
    }
    return address;
}
//# sourceMappingURL=resolveUNSAddress.js.map