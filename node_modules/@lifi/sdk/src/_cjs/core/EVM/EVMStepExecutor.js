"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EVMStepExecutor = void 0;
const actions_1 = require("viem/actions");
const utils_1 = require("viem/utils");
const config_js_1 = require("../../config.js");
const constants_js_1 = require("../../errors/constants.js");
const errors_js_1 = require("../../errors/errors.js");
const api_js_1 = require("../../services/api.js");
const isZeroAddress_js_1 = require("../../utils/isZeroAddress.js");
const BaseStepExecutor_js_1 = require("../BaseStepExecutor.js");
const checkBalance_js_1 = require("../checkBalance.js");
const stepComparison_js_1 = require("../stepComparison.js");
const waitForDestinationChainTransaction_js_1 = require("../waitForDestinationChainTransaction.js");
const checkAllowance_js_1 = require("./checkAllowance.js");
const getActionWithFallback_js_1 = require("./getActionWithFallback.js");
const isBatchingSupported_js_1 = require("./isBatchingSupported.js");
const parseEVMErrors_js_1 = require("./parseEVMErrors.js");
const encodeNativePermitData_js_1 = require("./permits/encodeNativePermitData.js");
const encodePermit2Data_js_1 = require("./permits/encodePermit2Data.js");
const signPermit2Message_js_1 = require("./permits/signPermit2Message.js");
const switchChain_js_1 = require("./switchChain.js");
const typeguards_js_1 = require("./typeguards.js");
const utils_js_1 = require("./utils.js");
const waitForBatchTransactionReceipt_js_1 = require("./waitForBatchTransactionReceipt.js");
const waitForRelayedTransactionReceipt_js_1 = require("./waitForRelayedTransactionReceipt.js");
const waitForTransactionReceipt_js_1 = require("./waitForTransactionReceipt.js");
class EVMStepExecutor extends BaseStepExecutor_js_1.BaseStepExecutor {
    client;
    constructor(options) {
        super(options);
        this.client = options.client;
    }
    checkClient = async (step, process) => {
        const updatedClient = await (0, switchChain_js_1.switchChain)(this.client, this.statusManager, step, this.allowUserInteraction, this.executionOptions?.switchChainHook);
        if (updatedClient) {
            this.client = updatedClient;
        }
        let accountAddress = this.client.account?.address;
        if (!accountAddress) {
            const accountAddresses = (await (0, utils_1.getAction)(this.client, actions_1.getAddresses, 'getAddresses')(undefined));
            accountAddress = accountAddresses?.[0];
        }
        if (accountAddress?.toLowerCase() !== step.action.fromAddress?.toLowerCase()) {
            let processToUpdate = process;
            if (!processToUpdate) {
                processToUpdate = this.statusManager.findOrCreateProcess({
                    step,
                    type: 'TRANSACTION',
                });
            }
            const errorMessage = 'The wallet address that requested the quote does not match the wallet address attempting to sign the transaction.';
            this.statusManager.updateProcess(step, processToUpdate.type, 'FAILED', {
                error: {
                    code: constants_js_1.LiFiErrorCode.WalletChangedDuringExecution,
                    message: errorMessage,
                },
            });
            this.statusManager.updateExecution(step, 'FAILED');
            throw await (0, parseEVMErrors_js_1.parseEVMErrors)(new errors_js_1.TransactionError(constants_js_1.LiFiErrorCode.WalletChangedDuringExecution, errorMessage), step, process);
        }
        return updatedClient;
    };
    waitForTransaction = async ({ step, process, fromChain, toChain, isBridgeExecution, }) => {
        let transactionReceipt;
        switch (process.txType) {
            case 'batched':
                transactionReceipt = await (0, waitForBatchTransactionReceipt_js_1.waitForBatchTransactionReceipt)(this.client, process.taskId);
                break;
            case 'relayed':
                transactionReceipt = await (0, waitForRelayedTransactionReceipt_js_1.waitForRelayedTransactionReceipt)(process.taskId, step);
                break;
            default:
                transactionReceipt = await (0, waitForTransactionReceipt_js_1.waitForTransactionReceipt)({
                    client: this.client,
                    chainId: fromChain.id,
                    txHash: process.txHash,
                    onReplaced: (response) => {
                        this.statusManager.updateProcess(step, process.type, 'PENDING', {
                            txHash: response.transaction.hash,
                            txLink: `${fromChain.metamask.blockExplorerUrls[0]}tx/${response.transaction.hash}`,
                        });
                    },
                });
        }
        if (transactionReceipt?.transactionHash &&
            transactionReceipt.transactionHash !== process.txHash) {
            const txHash = (0, utils_1.isHex)(transactionReceipt.transactionHash, { strict: true })
                ? transactionReceipt.transactionHash
                : undefined;
            process = this.statusManager.updateProcess(step, process.type, 'PENDING', {
                txHash: txHash,
                txLink: transactionReceipt.transactionLink ||
                    (txHash
                        ? `${fromChain.metamask.blockExplorerUrls[0]}tx/${txHash}`
                        : undefined),
            });
        }
        if (isBridgeExecution) {
            process = this.statusManager.updateProcess(step, process.type, 'DONE');
        }
        await (0, waitForDestinationChainTransaction_js_1.waitForDestinationChainTransaction)(step, process, fromChain, toChain, this.statusManager);
    };
    getUpdatedStep = async (step, signedNativePermitTypedData) => {
        const { execution, ...stepBase } = step;
        const relayerStep = (0, typeguards_js_1.isRelayerStep)(step);
        const gaslessStep = (0, typeguards_js_1.isGaslessStep)(step);
        if (relayerStep && gaslessStep) {
            const updatedRelayedStep = await (0, api_js_1.getRelayerQuote)({
                fromChain: stepBase.action.fromChainId,
                fromToken: stepBase.action.fromToken.address,
                fromAddress: stepBase.action.fromAddress,
                fromAmount: stepBase.action.fromAmount,
                toChain: stepBase.action.toChainId,
                toToken: stepBase.action.toToken.address,
                slippage: stepBase.action.slippage,
                toAddress: stepBase.action.toAddress,
                allowBridges: [stepBase.tool],
            });
            return {
                ...updatedRelayedStep,
                id: stepBase.id,
            };
        }
        const params = relayerStep && !gaslessStep && signedNativePermitTypedData
            ? { ...stepBase, typedData: [signedNativePermitTypedData] }
            : stepBase;
        return (0, api_js_1.getStepTransaction)(params);
    };
    executeStep = async (step, atomicityNotReady = false) => {
        step.execution = this.statusManager.initExecutionObject(step);
        const destinationChainProcess = step.execution?.process.find((process) => process.type === 'RECEIVING_CHAIN');
        if (destinationChainProcess?.substatus !== 'WAIT_DESTINATION_TRANSACTION') {
            const updatedClient = await this.checkClient(step);
            if (!updatedClient) {
                return step;
            }
        }
        const fromChain = await config_js_1.config.getChainById(step.action.fromChainId);
        const toChain = await config_js_1.config.getChainById(step.action.toChainId);
        let isRelayerTransaction = (0, typeguards_js_1.isRelayerStep)(step);
        const calls = [];
        const batchingSupported = atomicityNotReady || step.tool === 'thorswap'
            ? false
            : !isRelayerTransaction &&
                (await (0, isBatchingSupported_js_1.isBatchingSupported)({
                    client: this.client,
                    chainId: fromChain.id,
                }));
        const isBridgeExecution = fromChain.id !== toChain.id;
        const currentProcessType = isBridgeExecution ? 'CROSS_CHAIN' : 'SWAP';
        const existingProcess = step.execution.process.find((p) => p.type === currentProcessType);
        const isFromNativeToken = fromChain.nativeToken.address === step.action.fromToken.address &&
            (0, isZeroAddress_js_1.isZeroAddress)(step.action.fromToken.address);
        const disableMessageSigning = this.executionOptions?.disableMessageSigning || step.type !== 'lifi';
        const permit2Supported = !!fromChain.permit2 &&
            !!fromChain.permit2Proxy &&
            !batchingSupported &&
            !isFromNativeToken &&
            !disableMessageSigning &&
            !!step.estimate.approvalAddress;
        const checkForAllowance = !existingProcess?.txHash &&
            !existingProcess?.taskId &&
            !isFromNativeToken &&
            !!step.estimate.approvalAddress;
        let signedNativePermitTypedData;
        if (checkForAllowance) {
            const allowanceResult = await (0, checkAllowance_js_1.checkAllowance)({
                client: this.client,
                chain: fromChain,
                step,
                statusManager: this.statusManager,
                executionOptions: this.executionOptions,
                allowUserInteraction: this.allowUserInteraction,
                batchingSupported,
                permit2Supported,
                disableMessageSigning,
            });
            if (allowanceResult.status === 'BATCH_APPROVAL') {
                if (batchingSupported) {
                    calls.push(allowanceResult.data);
                }
            }
            if (allowanceResult.status === 'NATIVE_PERMIT') {
                signedNativePermitTypedData = allowanceResult.data;
            }
            if (allowanceResult.status === 'ACTION_REQUIRED' &&
                !this.allowUserInteraction) {
                return step;
            }
        }
        let process = this.statusManager.findProcess(step, currentProcessType);
        try {
            if (process?.status === 'DONE') {
                await (0, waitForDestinationChainTransaction_js_1.waitForDestinationChainTransaction)(step, process, fromChain, toChain, this.statusManager);
                return step;
            }
            if (process?.txHash || process?.taskId) {
                const updatedClient = await this.checkClient(step, process);
                if (!updatedClient) {
                    return step;
                }
                await this.waitForTransaction({
                    step,
                    process,
                    fromChain,
                    toChain,
                    isBridgeExecution,
                });
                return step;
            }
            const permitRequired = !batchingSupported && !signedNativePermitTypedData && permit2Supported;
            process = this.statusManager.findOrCreateProcess({
                step,
                type: permitRequired ? 'PERMIT' : currentProcessType,
                status: 'STARTED',
                chainId: fromChain.id,
            });
            await (0, checkBalance_js_1.checkBalance)(this.client.account.address, step);
            if (!step.transactionRequest &&
                !step.typedData?.some((p) => p.primaryType !== 'Permit')) {
                const updatedStep = await this.getUpdatedStep(step, signedNativePermitTypedData);
                const comparedStep = await (0, stepComparison_js_1.stepComparison)(this.statusManager, step, updatedStep, this.allowUserInteraction, this.executionOptions);
                Object.assign(step, {
                    ...comparedStep,
                    execution: step.execution,
                });
                isRelayerTransaction = (0, typeguards_js_1.isRelayerStep)(comparedStep);
            }
            if (!step.transactionRequest &&
                !step.typedData?.some((p) => p.primaryType !== 'Permit')) {
                throw new errors_js_1.TransactionError(constants_js_1.LiFiErrorCode.TransactionUnprepared, 'Unable to prepare transaction.');
            }
            let transactionRequest;
            if (step.transactionRequest) {
                transactionRequest = {
                    to: step.transactionRequest.to,
                    from: step.transactionRequest.from,
                    data: step.transactionRequest.data,
                    value: step.transactionRequest.value
                        ? BigInt(step.transactionRequest.value)
                        : undefined,
                    gas: step.transactionRequest.gasLimit
                        ? BigInt(step.transactionRequest.gasLimit)
                        : undefined,
                    maxPriorityFeePerGas: this.client.account?.type === 'local'
                        ? await (0, utils_js_1.getMaxPriorityFeePerGas)(this.client)
                        : step.transactionRequest.maxPriorityFeePerGas
                            ? BigInt(step.transactionRequest.maxPriorityFeePerGas)
                            : undefined,
                };
            }
            if (this.executionOptions?.updateTransactionRequestHook &&
                transactionRequest) {
                const customizedTransactionRequest = await this.executionOptions.updateTransactionRequestHook({
                    requestType: 'transaction',
                    ...transactionRequest,
                });
                transactionRequest = {
                    ...transactionRequest,
                    ...customizedTransactionRequest,
                };
            }
            const updatedClient = await this.checkClient(step, process);
            if (!updatedClient) {
                return step;
            }
            process = this.statusManager.updateProcess(step, process.type, 'ACTION_REQUIRED');
            if (!this.allowUserInteraction) {
                return step;
            }
            let txHash;
            let taskId;
            let txType = 'standard';
            let txLink;
            if (batchingSupported && transactionRequest) {
                const transferCall = {
                    chainId: fromChain.id,
                    data: transactionRequest.data,
                    to: transactionRequest.to,
                    value: transactionRequest.value,
                };
                calls.push(transferCall);
                const { id } = await (0, utils_1.getAction)(this.client, actions_1.sendCalls, 'sendCalls')({
                    account: this.client.account,
                    calls,
                });
                taskId = id;
                txType = 'batched';
            }
            else if (isRelayerTransaction) {
                const relayerTypedData = step.typedData?.find((p) => p.primaryType !== 'Permit');
                if (!relayerTypedData) {
                    throw new errors_js_1.TransactionError(constants_js_1.LiFiErrorCode.TransactionUnprepared, 'Unable to prepare transaction. Typed data for transfer is not found.');
                }
                const signature = await (0, utils_1.getAction)(this.client, actions_1.signTypedData, 'signTypedData')({
                    account: this.client.account,
                    primaryType: relayerTypedData.primaryType,
                    domain: relayerTypedData.domain,
                    types: relayerTypedData.types,
                    message: relayerTypedData.message,
                });
                this.statusManager.updateProcess(step, process.type, 'DONE');
                process = this.statusManager.findOrCreateProcess({
                    step,
                    type: currentProcessType,
                    status: 'PENDING',
                    chainId: fromChain.id,
                });
                const signedTypedData = [
                    {
                        ...relayerTypedData,
                        signature: signature,
                    },
                ];
                if (signedNativePermitTypedData) {
                    signedTypedData.unshift(signedNativePermitTypedData);
                }
                const { execution, ...stepBase } = step;
                const relayedTransaction = await (0, api_js_1.relayTransaction)({
                    ...stepBase,
                    typedData: signedTypedData,
                });
                taskId = relayedTransaction.taskId;
                txType = 'relayed';
                txLink = relayedTransaction.txLink;
            }
            else {
                if (!transactionRequest) {
                    throw new errors_js_1.TransactionError(constants_js_1.LiFiErrorCode.TransactionUnprepared, 'Unable to prepare transaction. Transaction request is not found.');
                }
                if (signedNativePermitTypedData) {
                    transactionRequest.data = (0, encodeNativePermitData_js_1.encodeNativePermitData)(step.action.fromToken.address, BigInt(step.action.fromAmount), signedNativePermitTypedData.message.deadline, signedNativePermitTypedData.signature, transactionRequest.data);
                }
                else if (permit2Supported) {
                    const permit2Signature = await (0, signPermit2Message_js_1.signPermit2Message)({
                        client: this.client,
                        chain: fromChain,
                        tokenAddress: step.action.fromToken.address,
                        amount: BigInt(step.action.fromAmount),
                        data: transactionRequest.data,
                    });
                    this.statusManager.updateProcess(step, process.type, 'DONE');
                    process = this.statusManager.findOrCreateProcess({
                        step,
                        type: currentProcessType,
                        status: 'PENDING',
                        chainId: fromChain.id,
                    });
                    transactionRequest.data = (0, encodePermit2Data_js_1.encodePermit2Data)(step.action.fromToken.address, BigInt(step.action.fromAmount), permit2Signature.message.nonce, permit2Signature.message.deadline, transactionRequest.data, permit2Signature.signature);
                }
                if (signedNativePermitTypedData || permit2Supported) {
                    transactionRequest.to = fromChain.permit2Proxy;
                    try {
                        const estimatedGas = await (0, getActionWithFallback_js_1.getActionWithFallback)(this.client, actions_1.estimateGas, 'estimateGas', {
                            account: this.client.account,
                            to: transactionRequest.to,
                            data: transactionRequest.data,
                            value: transactionRequest.value,
                        });
                        transactionRequest.gas =
                            transactionRequest.gas && transactionRequest.gas > estimatedGas
                                ? transactionRequest.gas
                                : estimatedGas;
                    }
                    catch (_) {
                        if (transactionRequest.gas) {
                            transactionRequest.gas = transactionRequest.gas + 80000n;
                        }
                    }
                    finally {
                        this.statusManager.updateProcess(step, process.type, 'DONE');
                    }
                }
                process = this.statusManager.updateProcess(step, process.type, 'ACTION_REQUIRED');
                txHash = await (0, utils_1.getAction)(this.client, actions_1.sendTransaction, 'sendTransaction')({
                    to: transactionRequest.to,
                    account: this.client.account,
                    data: transactionRequest.data,
                    value: transactionRequest.value,
                    gas: transactionRequest.gas,
                    gasPrice: transactionRequest.gasPrice,
                    maxFeePerGas: transactionRequest.maxFeePerGas,
                    maxPriorityFeePerGas: transactionRequest.maxPriorityFeePerGas,
                    chain: (0, utils_js_1.convertExtendedChain)(fromChain),
                });
            }
            process = this.statusManager.updateProcess(step, process.type, 'PENDING', {
                txHash,
                taskId,
                txType,
                txLink: txType === 'standard' && txHash
                    ? `${fromChain.metamask.blockExplorerUrls[0]}tx/${txHash}`
                    : txLink,
            });
            await this.waitForTransaction({
                step,
                process,
                fromChain,
                toChain,
                isBridgeExecution,
            });
            return step;
        }
        catch (e) {
            if ((0, parseEVMErrors_js_1.isAtomicReadyWalletRejectedUpgradeError)(e) && !atomicityNotReady) {
                step.execution = undefined;
                return this.executeStep(step, true);
            }
            const error = await (0, parseEVMErrors_js_1.parseEVMErrors)(e, step, process);
            process = this.statusManager.updateProcess(step, process?.type || currentProcessType, 'FAILED', {
                error: {
                    message: error.cause.message,
                    code: error.code,
                },
            });
            this.statusManager.updateExecution(step, 'FAILED');
            throw error;
        }
    };
}
exports.EVMStepExecutor = EVMStepExecutor;
//# sourceMappingURL=EVMStepExecutor.js.map