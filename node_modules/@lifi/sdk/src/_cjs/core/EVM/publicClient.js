"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPublicClient = void 0;
const types_1 = require("@lifi/types");
const viem_1 = require("viem");
const chains_1 = require("viem/chains");
const config_js_1 = require("../../config.js");
const rpc_js_1 = require("../rpc.js");
const constants_js_1 = require("./uns/constants.js");
const publicClients = {};
const getPublicClient = async (chainId) => {
    if (publicClients[chainId]) {
        return publicClients[chainId];
    }
    const urls = await (0, rpc_js_1.getRpcUrls)(chainId);
    const fallbackTransports = urls.map((url) => url.startsWith('wss')
        ? (0, viem_1.webSocket)(url)
        : (0, viem_1.http)(url, {
            batch: {
                batchSize: 64,
            },
        }));
    const _chain = await config_js_1.config.getChainById(chainId);
    const chain = {
        ..._chain,
        ..._chain.metamask,
        name: _chain.metamask.chainName,
        rpcUrls: {
            default: { http: _chain.metamask.rpcUrls },
            public: { http: _chain.metamask.rpcUrls },
        },
    };
    if (chain.id === types_1.ChainId.ETH) {
        chain.contracts = {
            ...chains_1.mainnet.contracts,
            ...chain.contracts,
        };
    }
    if (chain.id === types_1.ChainId.ETH || chain.id === types_1.ChainId.POL) {
        const unsProxyAddress = constants_js_1.UNS_PROXY_READER_ADDRESSES[chain.id];
        chain.contracts = {
            ...chain.contracts,
            unsProxyReader: { address: unsProxyAddress },
        };
    }
    const provider = config_js_1.config.getProvider(types_1.ChainType.EVM);
    publicClients[chainId] = (0, viem_1.createClient)({
        chain: chain,
        transport: (0, viem_1.fallback)(fallbackTransports, provider?.options?.fallbackTransportConfig),
        batch: {
            multicall: true,
        },
    });
    return publicClients[chainId];
};
exports.getPublicClient = getPublicClient;
//# sourceMappingURL=publicClient.js.map