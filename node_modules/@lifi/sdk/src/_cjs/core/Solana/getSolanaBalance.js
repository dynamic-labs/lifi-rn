"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSolanaBalance = void 0;
const web3_js_1 = require("@solana/web3.js");
const constants_js_1 = require("../../constants.js");
const withDedupe_js_1 = require("../../utils/withDedupe.js");
const connection_js_1 = require("./connection.js");
const types_js_1 = require("./types.js");
const getSolanaBalance = async (walletAddress, tokens) => {
    if (tokens.length === 0) {
        return [];
    }
    const { chainId } = tokens[0];
    for (const token of tokens) {
        if (token.chainId !== chainId) {
            console.warn('Requested tokens have to be on the same chain.');
        }
    }
    return getSolanaBalanceDefault(chainId, tokens, walletAddress);
};
exports.getSolanaBalance = getSolanaBalance;
const getSolanaBalanceDefault = async (_chainId, tokens, walletAddress) => {
    const accountPublicKey = new web3_js_1.PublicKey(walletAddress);
    const tokenProgramIdPublicKey = new web3_js_1.PublicKey(types_js_1.TokenProgramId);
    const token2022ProgramIdPublicKey = new web3_js_1.PublicKey(types_js_1.Token2022ProgramId);
    const [slot, balance, tokenAccountsByOwner, token2022AccountsByOwner] = await Promise.allSettled([
        (0, withDedupe_js_1.withDedupe)(() => (0, connection_js_1.callSolanaWithRetry)((connection) => connection.getSlot('confirmed')), { id: `${getSolanaBalanceDefault.name}.getSlot` }),
        (0, withDedupe_js_1.withDedupe)(() => (0, connection_js_1.callSolanaWithRetry)((connection) => connection.getBalance(accountPublicKey, 'confirmed')), { id: `${getSolanaBalanceDefault.name}.getBalance` }),
        (0, withDedupe_js_1.withDedupe)(() => (0, connection_js_1.callSolanaWithRetry)((connection) => connection.getParsedTokenAccountsByOwner(accountPublicKey, {
            programId: tokenProgramIdPublicKey,
        }, 'confirmed')), {
            id: `${getSolanaBalanceDefault.name}.getParsedTokenAccountsByOwner.${types_js_1.TokenProgramId}`,
        }),
        (0, withDedupe_js_1.withDedupe)(() => (0, connection_js_1.callSolanaWithRetry)((connection) => connection.getParsedTokenAccountsByOwner(accountPublicKey, {
            programId: token2022ProgramIdPublicKey,
        }, 'confirmed')), {
            id: `${getSolanaBalanceDefault.name}.getParsedTokenAccountsByOwner.${types_js_1.Token2022ProgramId}`,
        }),
    ]);
    const blockNumber = slot.status === 'fulfilled' ? BigInt(slot.value) : 0n;
    const solBalance = balance.status === 'fulfilled' ? BigInt(balance.value) : 0n;
    const walletTokenAmounts = [
        ...(tokenAccountsByOwner.status === 'fulfilled'
            ? tokenAccountsByOwner.value.value
            : []),
        ...(token2022AccountsByOwner.status === 'fulfilled'
            ? token2022AccountsByOwner.value.value
            : []),
    ].reduce((tokenAmounts, value) => {
        const amount = BigInt(value.account.data.parsed.info.tokenAmount.amount);
        if (amount > 0n) {
            tokenAmounts[value.account.data.parsed.info.mint] = amount;
        }
        return tokenAmounts;
    }, {});
    walletTokenAmounts[constants_js_1.SolSystemProgram] = solBalance;
    const tokenAmounts = tokens.map((token) => {
        if (walletTokenAmounts[token.address]) {
            return {
                ...token,
                amount: walletTokenAmounts[token.address],
                blockNumber,
            };
        }
        return {
            ...token,
            blockNumber,
        };
    });
    return tokenAmounts;
};
//# sourceMappingURL=getSolanaBalance.js.map