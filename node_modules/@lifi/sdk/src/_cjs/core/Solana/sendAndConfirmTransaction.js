"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sendAndConfirmTransaction = sendAndConfirmTransaction;
const bs58_1 = require("bs58");
const sleep_js_1 = require("../../utils/sleep.js");
const connection_js_1 = require("./connection.js");
async function sendAndConfirmTransaction(signedTx) {
    const connections = await (0, connection_js_1.getSolanaConnections)();
    const signedTxSerialized = signedTx.serialize();
    const txSignature = bs58_1.default.encode(signedTx.signatures[0]);
    if (!txSignature) {
        throw new Error('Transaction signature is missing.');
    }
    const rawTransactionOptions = {
        skipPreflight: true,
        maxRetries: 0,
        preflightCommitment: 'confirmed',
    };
    const abortController = new AbortController();
    const confirmPromises = connections.map(async (connection) => {
        try {
            try {
                await connection.sendRawTransaction(signedTxSerialized, rawTransactionOptions);
            }
            catch (_) {
            }
            const [blockhashResult, initialBlockHeight] = await Promise.all([
                connection.getLatestBlockhash('confirmed'),
                connection.getBlockHeight('confirmed'),
            ]);
            let currentBlockHeight = initialBlockHeight;
            let signatureResult = null;
            const pollingPromise = (async () => {
                while (currentBlockHeight < blockhashResult.lastValidBlockHeight &&
                    !abortController.signal.aborted) {
                    const statusResponse = await connection.getSignatureStatuses([
                        txSignature,
                    ]);
                    const status = statusResponse.value[0];
                    if (status &&
                        (status.confirmationStatus === 'confirmed' ||
                            status.confirmationStatus === 'finalized')) {
                        signatureResult = status;
                        abortController.abort();
                        return status;
                    }
                    await (0, sleep_js_1.sleep)(400);
                }
                return null;
            })();
            const sendingPromise = (async () => {
                while (currentBlockHeight < blockhashResult.lastValidBlockHeight &&
                    !abortController.signal.aborted &&
                    !signatureResult) {
                    try {
                        await connection.sendRawTransaction(signedTxSerialized, rawTransactionOptions);
                    }
                    catch (_) {
                    }
                    await (0, sleep_js_1.sleep)(1000);
                    if (!abortController.signal.aborted) {
                        currentBlockHeight = await connection.getBlockHeight('confirmed');
                    }
                }
                return null;
            })();
            const result = await Promise.race([pollingPromise, sendingPromise]);
            return result;
        }
        catch (error) {
            if (abortController.signal.aborted) {
                return null;
            }
            throw error;
        }
    });
    const signatureResult = await Promise.any(confirmPromises).catch(() => null);
    if (!abortController.signal.aborted) {
        abortController.abort();
    }
    return { signatureResult, txSignature };
}
//# sourceMappingURL=sendAndConfirmTransaction.js.map