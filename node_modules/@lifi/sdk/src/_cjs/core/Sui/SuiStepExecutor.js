"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SuiStepExecutor = void 0;
const wallet_standard_1 = require("@mysten/wallet-standard");
const config_js_1 = require("../../config.js");
const constants_js_1 = require("../../errors/constants.js");
const errors_js_1 = require("../../errors/errors.js");
const api_js_1 = require("../../services/api.js");
const BaseStepExecutor_js_1 = require("../BaseStepExecutor.js");
const checkBalance_js_1 = require("../checkBalance.js");
const stepComparison_js_1 = require("../stepComparison.js");
const waitForDestinationChainTransaction_js_1 = require("../waitForDestinationChainTransaction.js");
const parseSuiErrors_js_1 = require("./parseSuiErrors.js");
const suiClient_js_1 = require("./suiClient.js");
class SuiStepExecutor extends BaseStepExecutor_js_1.BaseStepExecutor {
    wallet;
    constructor(options) {
        super(options);
        this.wallet = options.wallet;
    }
    checkWallet = (step) => {
        if (!this.wallet.accounts?.some?.((account) => account.address === step.action.fromAddress)) {
            throw new errors_js_1.TransactionError(constants_js_1.LiFiErrorCode.WalletChangedDuringExecution, 'The wallet address that requested the quote does not match the wallet address attempting to sign the transaction.');
        }
    };
    executeStep = async (step) => {
        step.execution = this.statusManager.initExecutionObject(step);
        const fromChain = await config_js_1.config.getChainById(step.action.fromChainId);
        const toChain = await config_js_1.config.getChainById(step.action.toChainId);
        const isBridgeExecution = fromChain.id !== toChain.id;
        const currentProcessType = isBridgeExecution ? 'CROSS_CHAIN' : 'SWAP';
        let process = this.statusManager.findOrCreateProcess({
            step,
            type: currentProcessType,
            chainId: fromChain.id,
        });
        if (process.status !== 'DONE') {
            try {
                process = this.statusManager.updateProcess(step, process.type, 'STARTED');
                await (0, checkBalance_js_1.checkBalance)(step.action.fromAddress, step);
                if (!step.transactionRequest) {
                    const { execution, ...stepBase } = step;
                    const updatedStep = await (0, api_js_1.getStepTransaction)(stepBase);
                    const comparedStep = await (0, stepComparison_js_1.stepComparison)(this.statusManager, step, updatedStep, this.allowUserInteraction, this.executionOptions);
                    Object.assign(step, {
                        ...comparedStep,
                        execution: step.execution,
                    });
                }
                if (!step.transactionRequest?.data) {
                    throw new errors_js_1.TransactionError(constants_js_1.LiFiErrorCode.TransactionUnprepared, 'Unable to prepare transaction.');
                }
                process = this.statusManager.updateProcess(step, process.type, 'ACTION_REQUIRED');
                if (!this.allowUserInteraction) {
                    return step;
                }
                let transactionRequest = {
                    data: step.transactionRequest.data,
                };
                if (this.executionOptions?.updateTransactionRequestHook) {
                    const customizedTransactionRequest = await this.executionOptions.updateTransactionRequestHook({
                        requestType: 'transaction',
                        ...transactionRequest,
                    });
                    transactionRequest = {
                        ...transactionRequest,
                        ...customizedTransactionRequest,
                    };
                }
                const transactionRequestData = transactionRequest.data;
                if (!transactionRequestData) {
                    throw new errors_js_1.TransactionError(constants_js_1.LiFiErrorCode.TransactionUnprepared, 'Unable to prepare transaction.');
                }
                this.checkWallet(step);
                const signedTx = await (0, wallet_standard_1.signAndExecuteTransaction)(this.wallet, {
                    account: this.wallet.accounts.find((account) => account.address === step.action.fromAddress),
                    chain: 'sui:mainnet',
                    transaction: {
                        toJSON: async () => transactionRequestData,
                    },
                });
                process = this.statusManager.updateProcess(step, process.type, 'PENDING');
                const result = await (0, suiClient_js_1.callSuiWithRetry)((client) => client.waitForTransaction({
                    digest: signedTx.digest,
                    options: {
                        showEffects: true,
                    },
                }));
                if (result.effects?.status.status !== 'success') {
                    throw new errors_js_1.TransactionError(constants_js_1.LiFiErrorCode.TransactionFailed, `Transaction failed: ${result.effects?.status.error}`);
                }
                process = this.statusManager.updateProcess(step, process.type, 'PENDING', {
                    txHash: result.digest,
                    txLink: `${fromChain.metamask.blockExplorerUrls[0]}txblock/${result.digest}`,
                });
                if (isBridgeExecution) {
                    process = this.statusManager.updateProcess(step, process.type, 'DONE');
                }
            }
            catch (e) {
                const error = await (0, parseSuiErrors_js_1.parseSuiErrors)(e, step, process);
                process = this.statusManager.updateProcess(step, process.type, 'FAILED', {
                    error: {
                        message: error.cause.message,
                        code: error.code,
                    },
                });
                this.statusManager.updateExecution(step, 'FAILED');
                throw error;
            }
        }
        await (0, waitForDestinationChainTransaction_js_1.waitForDestinationChainTransaction)(step, process, fromChain, toChain, this.statusManager);
        return step;
    };
}
exports.SuiStepExecutor = SuiStepExecutor;
//# sourceMappingURL=SuiStepExecutor.js.map