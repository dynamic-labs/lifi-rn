'use client'
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _tslib = require('../../_virtual/_tslib.cjs');
var walletConnectorCore = require('@dynamic-labs/wallet-connector-core');
var utils = require('@dynamic-labs/utils');
require('@solana/web3.js');
require('@solana/spl-token');
var createNonNativeTokenTransfer = require('../utils/createNonNativeTokenTransfer/createNonNativeTokenTransfer.cjs');
var createSolTransfer = require('../utils/createSolTransfer/createSolTransfer.cjs');

class SolanaWallet extends walletConnectorCore.Wallet {
    /**
     * Sends the native balance of the wallet to the given address.
     * @param amount - The amount of balance to send (in SOL).
     * @param toAddress - The address to send the balance to.
     * @returns The signature of the sent transaction.
     */
    sendBalance(_a) {
        return _tslib.__awaiter(this, arguments, void 0, function* ({ amount, toAddress, token, }) {
            let transaction;
            const connection = yield this.getConnection();
            const signer = yield this.getSigner();
            const { blockhash, lastValidBlockHeight } = yield connection.getLatestBlockhash('finalized');
            if (token === null || token === void 0 ? void 0 : token.address) {
                transaction = yield createNonNativeTokenTransfer.createNonNativeTokenTransfer({
                    amount: Number(amount),
                    blockhash,
                    connection,
                    decimals: token.decimals,
                    fromAddress: this.address,
                    lastValidBlockHeight,
                    toAddress,
                    tokenAddress: token.address,
                });
            }
            else {
                transaction = yield createSolTransfer.createSolTransfer({
                    amount: Number(amount),
                    blockhash,
                    fromAddress: this.address,
                    toAddress,
                });
            }
            const { signature } = yield signer.signAndSendTransaction(transaction);
            return signature;
        });
    }
    /**
     * Retrieves the RPC connection
     * @returns A promise that resolves to the RPC connection
     */
    getConnection() {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            return this._connector.getWalletClient();
        });
    }
    /**
     * Retrieves the solana signer for the wallet.
     * @returns A promise that resolves to the signer,
     * or throws an error if the signer cannot be retrieved.
     */
    getSigner() {
        return _tslib.__awaiter(this, void 0, void 0, function* () {
            const signer = yield this._connector.getSigner();
            if (!signer) {
                throw new Error('unable to retrieve Solana signer');
            }
            try {
                return utils.cloneObjectWithOverrides(signer, {
                    signAllTransactions: (transactions) => _tslib.__awaiter(this, void 0, void 0, function* () {
                        yield this.sync();
                        return signer.signAllTransactions(transactions);
                    }),
                    signAndSendTransaction: (transaction, ...args) => _tslib.__awaiter(this, void 0, void 0, function* () {
                        yield this.sync();
                        return signer.signAndSendTransaction(transaction, ...args);
                    }),
                    signMessage: (message, ...args) => _tslib.__awaiter(this, void 0, void 0, function* () {
                        yield this.sync();
                        return signer.signMessage(message, ...args);
                    }),
                    signTransaction: (transaction) => _tslib.__awaiter(this, void 0, void 0, function* () {
                        yield this.sync();
                        return signer.signTransaction(transaction);
                    }),
                });
            }
            catch (error) {
                walletConnectorCore.logger.warn(`Failed to add logic to auto-sync the wallet. Signer might be out of sync for wallet: ${this._connector.name} (${this.address})`, error);
                return signer;
            }
        });
    }
}

exports.SolanaWallet = SolanaWallet;
