'use client'
import { __awaiter, __rest } from '../_virtual/_tslib.js';
import { publicActions, custom, createWalletClient, toHex, formatEther } from 'viem';
import { toAccount } from 'viem/accounts';
import { KERNEL_V3_3_BETA, KernelVersionToAddressesMap, getEntryPoint as getEntryPoint$1 } from '@zerodev/sdk/constants';
import { EthereumWallet, isEthWalletConnector, chainsMap, confirmationTransport, unFormatTransaction } from '@dynamic-labs/ethereum-core';
import { eventListenerHandlers } from '@dynamic-labs/wallet-connector-core';
import { parseEvmNetworks, StorageService, DynamicError, DeferredPromise, parseChainId, wrapMethodWithCallback, TransactionGasCannotBeSponsoredError, InsufficientFundsError } from '@dynamic-labs/utils';
import { AccountAbstractionBaseConnector } from '@dynamic-labs/ethereum-aa-core';
import { ZERO_DEV_LAST_USED_CHAIN_ID_KEY } from './constants.js';
import { logger } from './utils/logger.js';
import { createEcdsaKernelAccountClientWith7702, createEcdsaKernelAccountClient } from './utils/createEcdsaKernelAccountClient.js';
import { getEcdsaValidator } from './utils/getEcdsaValidator.js';
import { getEntryPoint } from './utils/getEntryPoint.js';
import { getKernelVersion } from './utils/getKernelVersion.js';
import { isEVMAuthorizationCapable } from './utils/isEVMAuthorizationCapable.js';

class ZeroDevConnector extends AccountAbstractionBaseConnector {
    constructor(opts) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        super(opts);
        // provider map maintains the kernel clients per chain
        this.providerMap = {};
        // eoa connector map maintains the eoa address and connector for each smart wallet address
        this.eoaConnectorMap = {};
        this.ChainWallet = EthereumWallet;
        this.connectedChain = 'EVM';
        this.supportedChains = ['ETH', 'EVM'];
        this.isEmbeddedWallet = true;
        this.providersFromApi = [];
        this.name = 'ZeroDev';
        this.overrideKey = 'zerodev';
        this.walletFallback = {
            brand: {
                alt: 'Smart Wallet',
                spriteId: 'smartwallet',
            },
            name: 'ZeroDev',
        };
        this._walletUiUtils = opts.walletUiUtils;
        this.providersConfig = (_a = opts.providersConfig) !== null && _a !== void 0 ? _a : {};
        this.enableEIP7702Mode = (_c = (_b = opts.apiProviders.zerodev) === null || _b === void 0 ? void 0 : _b.enableEIP7702) !== null && _c !== void 0 ? _c : false;
        this.entryPoint = getEntryPoint((_d = opts.apiProviders.zerodev) === null || _d === void 0 ? void 0 : _d.entryPointVersion);
        this.kernelVersion = getKernelVersion((_e = opts.apiProviders.zerodev) === null || _e === void 0 ? void 0 : _e.kernelVersion, this.entryPoint);
        this.enableKernelV3Migration =
            (_g = (_f = opts.apiProviders.zerodev) === null || _f === void 0 ? void 0 : _f.enableKernelV3Migration) !== null && _g !== void 0 ? _g : false;
        // this is the list of providers from the api that are used for multi-chain account abstraction
        this.providersFromApi =
            ((_h = opts.apiProviders.zerodev) === null || _h === void 0 ? void 0 : _h.multichainAccountAbstractionProviders) || [];
        const enabledZerodevNetworks = this.providersFromApi.map((provider) => provider.chain);
        this.evmNetworks = parseEvmNetworks(opts.evmNetworks).filter((network) => enabledZerodevNetworks.includes(network.chainId.toString()));
        const [defaultProvider] = this.providersFromApi;
        this.clientId = defaultProvider === null || defaultProvider === void 0 ? void 0 : defaultProvider.clientId;
        if (!this.clientId) {
            throw new Error('Missing ZeroDev project ID provided. Add your ZeroDev project id to your project configuration via the Dynamic Labs dashboard.');
        }
        this.defaultChainId = defaultProvider === null || defaultProvider === void 0 ? void 0 : defaultProvider.chain;
        this.ecdsaProviderType = (_j = opts.apiProviders.zerodev) === null || _j === void 0 ? void 0 : _j.ecdsaProviderType;
    }
    confirmTransactionStatus() {
        throw new Error('confirmTransactionStatus not implemented in ZeroDevConnector');
    }
    get currentNetworkProvider() {
        // check if the last used chain id is in the provider map
        if (this.providerMap[this.lastUsedChainId]) {
            return this.providerMap[this.lastUsedChainId];
        }
        // if not, check if the default chain id is in the provider map
        if (this.defaultChainId) {
            return this.providerMap[this.defaultChainId];
        }
        // if no chain id is found, return undefined
        return undefined;
    }
    get lastUsedChainId() {
        var _a;
        const storedChainId = StorageService.getItem(ZERO_DEV_LAST_USED_CHAIN_ID_KEY);
        // returning string of unknown if no chain id is found to result in undefined provider lookup
        return (_a = storedChainId !== null && storedChainId !== void 0 ? storedChainId : this.defaultChainId) !== null && _a !== void 0 ? _a : 'unknown';
    }
    get kernelClient() {
        var _a;
        return (_a = this.currentNetworkProvider) === null || _a === void 0 ? void 0 : _a.kernelClient;
    }
    get kernelClientWithSponsorship() {
        var _a;
        return (_a = this.currentNetworkProvider) === null || _a === void 0 ? void 0 : _a.kernelClientWithSponsorship;
    }
    supportsNetworkSwitching() {
        return (Object.keys(this.providerMap).length > 1 && this.evmNetworks.length > 1);
    }
    switchNetwork(_a) {
        return __awaiter(this, arguments, void 0, function* ({ networkChainId, }) {
            if (!this.supportsNetworkSwitching())
                return;
            if (!networkChainId)
                return;
            const chainId = networkChainId.toString();
            if (!this.providerMap[chainId]) {
                throw new Error(`No provider found for chainId: ${chainId}`);
            }
            StorageService.setItem(ZERO_DEV_LAST_USED_CHAIN_ID_KEY, chainId);
            const { handleChainChange } = eventListenerHandlers(this);
            handleChainChange(chainId);
        });
    }
    getAccountAbstractionProvider({ withSponsorship, } = {}) {
        if (withSponsorship && this.kernelClientWithSponsorship) {
            return this.kernelClientWithSponsorship;
        }
        return this.kernelClient;
    }
    endSession() {
        return __awaiter(this, void 0, void 0, function* () {
            StorageService.removeItem(ZERO_DEV_LAST_USED_CHAIN_ID_KEY);
        });
    }
    initialize(_a) {
        return __awaiter(this, arguments, void 0, function* ({ smartWalletAddress, eoaAddress, eoaConnector, properties, shouldSetEoaConnector, }) {
            yield this.registerEoa(Object.assign({ eoaAddress,
                eoaConnector,
                shouldSetEoaConnector,
                smartWalletAddress }, properties));
        });
    }
    registerEoa(_a) {
        return __awaiter(this, void 0, void 0, function* () {
            var { smartWalletAddress, eoaAddress, eoaConnector, shouldSetEoaConnector = false } = _a, properties = __rest(_a, ["smartWalletAddress", "eoaAddress", "eoaConnector", "shouldSetEoaConnector"]);
            if (this.enableEIP7702Mode) {
                // In EIP-7702, addresses must match
                if (smartWalletAddress !== eoaAddress) {
                    throw new Error('In EIP-7702 mode, smart wallet and EOA addresses must be the same');
                }
                yield this.setEoaConnector({
                    connector: eoaConnector,
                    eoaAddress,
                    properties,
                });
            }
            else {
                // Existing implementation for regular ZeroDev
                this.eoaConnectorMap[smartWalletAddress] = {
                    eoaAddress,
                    eoaConnector,
                    properties,
                };
                if (shouldSetEoaConnector) {
                    yield this.setEoaConnector({
                        connector: eoaConnector,
                        eoaAddress,
                        properties,
                    });
                }
            }
        });
    }
    getOrCreateAuthorization() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            if (!this.eoaConnector)
                throw new DynamicError('No EOA connector');
            if (!isEVMAuthorizationCapable(this.eoaConnector)) {
                throw new DynamicError('Connector does not support EVM authorization');
            }
            const ZERODEV_AUTHORIZATION = 'zerodev_authorization';
            try {
                const storedAuthorization = StorageService.getItem(ZERODEV_AUTHORIZATION);
                if (storedAuthorization) {
                    return storedAuthorization;
                }
                const kernelVersion = KERNEL_V3_3_BETA;
                const authorization = yield this.eoaConnector.experimental_signAuthorization({
                    contractAddress: (_a = ZeroDevConnector.kernelDelegationAddress) !== null && _a !== void 0 ? _a : KernelVersionToAddressesMap[kernelVersion]
                        .accountImplementationAddress,
                });
                if (authorization) {
                    const serializedAuth = Object.entries(authorization).reduce((acc, [key, value]) => {
                        acc[key] = typeof value === 'bigint' ? value.toString() : value;
                        return acc;
                    }, {});
                    StorageService.setItem(ZERODEV_AUTHORIZATION, serializedAuth);
                }
                return {
                    address: authorization.contractAddress,
                    chainId: authorization.chainId,
                    nonce: authorization.nonce,
                    r: authorization.r,
                    s: authorization.s,
                    v: authorization.v,
                    yParity: authorization.yParity,
                };
            }
            catch (error) {
                logger.error('Failed to get/set authorization:', error);
                StorageService.removeItem(ZERODEV_AUTHORIZATION);
                return undefined;
            }
        });
    }
    setEoaConnector(_a) {
        return __awaiter(this, arguments, void 0, function* ({ eoaAddress, connector, properties, }) {
            var _b, _c;
            if (!connector) {
                logger.error('No EOA connector provided');
                return;
            }
            this.kernelClientDeferredPromise = this.kernelClientDeferredPromise
                ? this.kernelClientDeferredPromise
                : new DeferredPromise();
            this.eoaConnector = connector;
            this.eoaAddress = eoaAddress;
            if (properties) {
                this.ecdsaProviderType =
                    (_b = properties.ecdsaProviderType) !== null && _b !== void 0 ? _b : this.ecdsaProviderType;
                this.entryPoint = properties.entryPointVersion
                    ? getEntryPoint(properties.entryPointVersion)
                    : this.entryPoint;
                this.kernelVersion = properties.entryPointVersion
                    ? getKernelVersion(properties.kernelVersion, this.entryPoint)
                    : this.kernelVersion;
                this.enableKernelV3Migration =
                    (_c = properties.enableKernelV3Migration) !== null && _c !== void 0 ? _c : this.enableKernelV3Migration;
            }
            if (isEthWalletConnector(this.eoaConnector) &&
                !this.eoaConnector.getActiveAccount()) {
                yield this.eoaConnector.getConnectedAccounts();
            }
            const signer = yield this.eoaConnector.getSigner();
            signer.account = toAccount(eoaAddress);
            if (this.enableEIP7702Mode) {
                this.authorization = yield this.getOrCreateAuthorization();
            }
            yield this.generateProviderMap(signer);
            this.kernelClientDeferredPromise.resolve();
        });
    }
    warnIfProjectChainNotEnabled(chainId) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            let chainIdToCheck = chainId;
            if (!chainIdToCheck) {
                const client = yield this.getPublicClient();
                chainIdToCheck = (_a = client === null || client === void 0 ? void 0 : client.chain) === null || _a === void 0 ? void 0 : _a.id;
            }
            const isProjectChainEnabled = this.evmNetworks.some((network) => network.chainId === chainIdToCheck);
            if (!isProjectChainEnabled) {
                logger.error(`Please make sure to enable (${chainIdToCheck}) in the Dynamic dashboard (https://app.dynamic.xyz/dashboard/configurations#evm).`);
            }
        });
    }
    /**
     * Generates a map of kernel clients for each chain in the providers list
     * Each chain gets two clients: one without sponsorship and one with sponsorship
     *
     * @param signer - The wallet client to use for signing transactions
     */
    generateProviderMap(signer) {
        return __awaiter(this, void 0, void 0, function* () {
            const providerMap = {};
            yield Promise.all(this.providersFromApi.map((provider) => __awaiter(this, void 0, void 0, function* () {
                const { chain, clientId } = provider;
                const [kernelClient, kernelClientWithSponsorship] = yield Promise.all([
                    this.createKernelClient({
                        chainId: chain,
                        paymaster: 'NONE',
                        projectId: clientId,
                        signer,
                    }),
                    this.createKernelClient({
                        authorization: this.authorization,
                        chainId: chain,
                        paymaster: 'SPONSOR',
                        projectId: clientId,
                        signer,
                    }),
                ]);
                providerMap[chain] = {
                    kernelClient,
                    kernelClientWithSponsorship,
                };
                yield this.warnIfProjectChainNotEnabled(parseChainId(chain));
            })));
            // Filter out duplicate chains and store the provider map
            const uniqueChainProviderMap = Object.entries(providerMap).reduce((acc, [chain, providers]) => {
                if (!acc[chain]) {
                    acc[chain] = providers;
                }
                return acc;
            }, {});
            this.providerMap = uniqueChainProviderMap;
        });
    }
    createKernelClient(_a) {
        return __awaiter(this, arguments, void 0, function* ({ chainId, projectId, signer, paymaster, authorization, }) {
            if (chainId && this.providerMap[chainId]) {
                return paymaster === 'SPONSOR'
                    ? this.providerMap[chainId].kernelClientWithSponsorship
                    : this.providerMap[chainId].kernelClient;
            }
            const { eoaConnector } = this;
            if (!eoaConnector)
                throw new DynamicError('No EOA connector');
            const chain = chainsMap[chainId];
            let kernelClient;
            if (this.enableEIP7702Mode) {
                kernelClient = yield createEcdsaKernelAccountClientWith7702({
                    authorization,
                    bundlerRpc: ZeroDevConnector.bundlerRpc,
                    chain,
                    ecdsaValidator: getEcdsaValidator(this.ecdsaProviderType),
                    enableKernelV3Migration: this.enableKernelV3Migration,
                    entryPoint: this.entryPoint,
                    kernelVersion: KERNEL_V3_3_BETA,
                    paymaster,
                    paymasterRpc: ZeroDevConnector.paymasterRpc,
                    projectId,
                    provider: ZeroDevConnector.bundlerProvider,
                    signer,
                });
            }
            else {
                kernelClient = yield createEcdsaKernelAccountClient({
                    bundlerRpc: ZeroDevConnector.bundlerRpc,
                    chain,
                    ecdsaValidator: getEcdsaValidator(this.ecdsaProviderType),
                    enableKernelV3Migration: this.enableKernelV3Migration,
                    entryPoint: this.entryPoint,
                    kernelVersion: this.kernelVersion,
                    paymaster,
                    paymasterRpc: ZeroDevConnector.paymasterRpc,
                    projectId,
                    provider: ZeroDevConnector.bundlerProvider,
                    signer,
                });
            }
            wrapMethodWithCallback(kernelClient, 'sendUserOperation', (original, ...args) => {
                this._walletUiUtils.disabledConfirmationOnce();
                return original(...args);
            });
            return kernelClient;
        });
    }
    getAddress() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c;
            if (this.enableEIP7702Mode) {
                return this.eoaAddress;
            }
            yield ((_a = this.kernelClientDeferredPromise) === null || _a === void 0 ? void 0 : _a.promise);
            return (_c = (_b = this.kernelClient) === null || _b === void 0 ? void 0 : _b.account) === null || _c === void 0 ? void 0 : _c.address;
        });
    }
    getConnectedAccounts() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c;
            yield ((_a = this.kernelClientDeferredPromise) === null || _a === void 0 ? void 0 : _a.promise);
            return ((_c = (_b = this.kernelClient) === null || _b === void 0 ? void 0 : _b.account) === null || _c === void 0 ? void 0 : _c.address)
                ? [yield this.kernelClient.account.address]
                : [];
        });
    }
    getNetwork() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            yield ((_a = this.kernelClientDeferredPromise) === null || _a === void 0 ? void 0 : _a.promise);
            return Number(this.lastUsedChainId);
        });
    }
    getTransport(provider) {
        const transport = confirmationTransport({
            getAccounts: () => __awaiter(this, void 0, void 0, function* () { return [provider.account.address]; }),
            onPersonalSign: (_a) => __awaiter(this, [_a], void 0, function* ({ message }) {
                this._walletUiUtils.disabledConfirmationOnce();
                return provider.signMessage({
                    message,
                });
            }),
            onSendTransaction: (_b) => __awaiter(this, [_b], void 0, function* ({ transaction }) {
                try {
                    this._walletUiUtils.disabledConfirmationOnce();
                    const effectiveProvider = this.isGasSponsorshipDisabled()
                        ? provider
                        : this.kernelClientWithSponsorship;
                    if (!effectiveProvider) {
                        throw new DynamicError('No provider');
                    }
                    const response = yield effectiveProvider.sendTransaction(unFormatTransaction(transaction));
                    return response;
                }
                catch (err) {
                    logger.debug(err);
                    if (TransactionGasCannotBeSponsoredError.isErrorMessage(err)) {
                        throw new TransactionGasCannotBeSponsoredError();
                    }
                    if (InsufficientFundsError.isErrorMessage(err)) {
                        throw new InsufficientFundsError();
                    }
                    throw err;
                }
            }),
            onSignTypedData: (_c) => __awaiter(this, [_c], void 0, function* ({ message }) {
                this._walletUiUtils.disabledConfirmationOnce();
                const signTypedData = JSON.parse(message);
                return provider.signTypedData({
                    domain: signTypedData.domain,
                    message: signTypedData.message,
                    primaryType: signTypedData.primaryType,
                    types: signTypedData.types,
                });
            }),
            provider: provider.extend(publicActions),
            transport: custom(provider, this.providersConfig.httpTransportConfig),
            // TODO: remove this. We should not be passing references to wallet connectors
            walletConnector: this,
            walletUiUtils: this._walletUiUtils,
        });
        return transport;
    }
    getWalletClient(chainId) {
        const provider = this.kernelClient;
        if (!provider)
            return undefined;
        const transport = this.getTransport(provider);
        const walletClient = createWalletClient({
            account: toAccount(provider.account.address),
            chain: chainId ? chainsMap[chainId] : provider.chain,
            transport,
        });
        return walletClient;
    }
    getPublicClient() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            const provider = (_a = this.kernelClient) === null || _a === void 0 ? void 0 : _a.extend(publicActions);
            if (!provider)
                return undefined;
            return provider;
        });
    }
    formatUserOperation(params) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            const kernelAccount = (_a = this.getAccountAbstractionProvider()) === null || _a === void 0 ? void 0 : _a.account;
            const entryPoint = kernelAccount === null || kernelAccount === void 0 ? void 0 : kernelAccount.entryPoint;
            const isV6 = (entryPoint === null || entryPoint === void 0 ? void 0 : entryPoint.address.toLowerCase()) ===
                getEntryPoint$1('0.6').address.toLowerCase();
            const factoryArgs = yield (kernelAccount === null || kernelAccount === void 0 ? void 0 : kernelAccount.getFactoryArgs());
            // we need the initCode in order to simulate the transaction
            // when the contract is not yet deployed
            const initCode = (factoryArgs === null || factoryArgs === void 0 ? void 0 : factoryArgs.factory) && (factoryArgs === null || factoryArgs === void 0 ? void 0 : factoryArgs.factoryData)
                ? '0x' +
                    factoryArgs.factory.slice(2).toLowerCase() +
                    factoryArgs.factoryData.slice(2).toLowerCase()
                : '0x';
            if (isV6) {
                return {
                    callData: params.callData,
                    callGasLimit: toHex(params.callGasLimit),
                    initCode,
                    maxFeePerGas: toHex(params.maxFeePerGas),
                    maxPriorityFeePerGas: toHex(params.maxPriorityFeePerGas),
                    nonce: toHex(params.nonce),
                    paymasterAndData: params.paymasterAndData.toLowerCase(),
                    preVerificationGas: toHex(params.preVerificationGas),
                    sender: params.sender,
                    signature: '0x',
                    verificationGasLimit: toHex(params.verificationGasLimit),
                };
            }
            const accountGasLimits = '0x' +
                toHex(params.verificationGasLimit).slice(2).padStart(32, '0') +
                toHex(params.callGasLimit).slice(2).padStart(32, '0');
            const preVerificationGas = toHex(params.preVerificationGas);
            const gasFees = '0x' +
                toHex(params.maxPriorityFeePerGas).slice(2).padStart(32, '0') +
                toHex(params.maxFeePerGas).slice(2).padStart(32, '0');
            const paymasterAndData = params.paymaster
                ? '0x' +
                    params.paymaster.slice(2).toLowerCase() +
                    toHex(params.paymasterVerificationGasLimit).slice(2).padStart(32, '0') + // Make sure it's 32 chars
                    toHex(params.paymasterPostOpGasLimit).slice(2).padStart(32, '0') + // Make sure it's 32 chars
                    params.paymasterData.slice(2) // Include full paymaster data
                : '0x';
            return {
                accountGasLimits: accountGasLimits,
                callData: params.callData,
                gasFees: gasFees,
                initCode,
                nonce: toHex(params.nonce),
                paymasterAndData: paymasterAndData.toLowerCase(),
                preVerificationGas: preVerificationGas,
                sender: params.sender,
                signature: '0x',
            };
        });
    }
    getCurrentUserOperation(transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            try {
                const { kernelClientWithSponsorship } = this;
                if (!kernelClientWithSponsorship) {
                    throw new DynamicError('No kernel client with sponsorship found');
                }
                const value = BigInt((_a = transaction.value) !== null && _a !== void 0 ? _a : 0);
                const callData = yield kernelClientWithSponsorship.account.encodeCalls([
                    {
                        data: transaction.data ? transaction.data : '0x',
                        to: transaction.to,
                        value,
                    },
                ]);
                let sponsorResult;
                let unsponsoredResult;
                try {
                    sponsorResult = yield kernelClientWithSponsorship.prepareUserOperation({
                        callData,
                    });
                }
                catch (err) {
                    logger.debug('[ZeroDevConnector] Sponsored UserOp Attempt Failed:', err);
                    unsponsoredResult = yield ((_b = this.kernelClient) === null || _b === void 0 ? void 0 : _b.prepareUserOperation({
                        callData,
                    }));
                }
                if ((sponsorResult === null || sponsorResult === void 0 ? void 0 : sponsorResult.paymasterAndData) === '0x')
                    return { sponsored: false, userOperation: sponsorResult };
                return sponsorResult
                    ? { sponsored: true, userOperation: sponsorResult }
                    : { sponsored: false, userOperation: unsponsoredResult };
            }
            catch (err) {
                logger.debug('[ZeroDevConnector] Error in getCurrentUserOperation:', err);
                return { sponsored: false, userOperation: undefined };
            }
        });
    }
    canSponsorTransactionGas(transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            const { sponsored } = yield this.getCurrentUserOperation(transaction);
            if (!sponsored) {
                return false;
            }
            return sponsored;
        });
    }
    getBalance(address) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            const rpcClient = (_a = this.kernelClient) === null || _a === void 0 ? void 0 : _a.extend(publicActions);
            if (!rpcClient)
                throw new DynamicError('No RPC client');
            return formatEther(yield rpcClient.getBalance({ address: address }));
        });
    }
    signMessage(messageToSign) {
        return __awaiter(this, void 0, void 0, function* () {
            const client = this === null || this === void 0 ? void 0 : this.kernelClient;
            // https://docs.zerodev.app/sdk/core-api/sign-and-verify#signing-messages
            if (!client)
                throw new Error('Error fetching signer');
            return client.signMessage({ message: messageToSign });
        });
    }
    validateActiveWallet(expectedAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.enableEIP7702Mode) {
                const currentAddress = yield this.getAddress();
                if (currentAddress !== expectedAddress) {
                    throw new DynamicError('Invalid active wallet');
                }
                return;
            }
            // Existing implementation for regular ZeroDev
            const eoa = this.eoaConnectorMap[expectedAddress];
            if (!eoa) {
                throw new DynamicError('No EOA connector');
            }
            const { eoaAddress, eoaConnector, properties } = eoa;
            yield eoaConnector.validateActiveWallet(eoaAddress);
            yield this.setEoaConnector({
                connector: eoaConnector,
                eoaAddress,
                properties,
            });
        });
    }
}

export { ZeroDevConnector };
