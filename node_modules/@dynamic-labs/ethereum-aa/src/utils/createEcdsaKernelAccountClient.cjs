'use client'
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _tslib = require('../../_virtual/_tslib.cjs');
var accounts = require('@zerodev/sdk/accounts');
var clients = require('@zerodev/sdk/clients');
var actions = require('@zerodev/sdk/actions');
var viem = require('viem');
var ecdsaValidator = require('@zerodev/ecdsa-validator');
var constants = require('@zerodev/sdk/constants');

const getZeroDevBundlerRPC = (projectId, provider) => {
    let rpc = `https://rpc.zerodev.app/api/v2/bundler/${projectId}`;
    if (provider) {
        rpc += `?bundlerProvider=${provider}`;
    }
    return rpc;
};
const getZeroDevPaymasterRPC = (projectId, provider) => {
    let rpc = `https://rpc.zerodev.app/api/v2/paymaster/${projectId}`;
    if (provider) {
        rpc += `?paymasterProvider=${provider}`;
    }
    return rpc;
};
const isERC20 = (value) => viem.isAddress(value);
const createPublicAndPaymasterClients = (bundlerRpc, paymasterRpc, chain) => {
    const publicClient = viem.createPublicClient({
        chain,
        transport: viem.http(bundlerRpc),
    });
    const zerodevPaymaster = clients.createZeroDevPaymasterClient({
        chain,
        transport: viem.http(paymasterRpc),
    });
    return { publicClient, zerodevPaymaster };
};
const createPaymasterHandler = (paymaster, zerodevPaymaster) => {
    if (paymaster === 'NONE')
        return undefined;
    return {
        getPaymasterData: (userOperation) => {
            const _userOperation = userOperation;
            if (isERC20(paymaster)) {
                return zerodevPaymaster.sponsorUserOperation({
                    gasToken: paymaster,
                    userOperation: _userOperation,
                });
            }
            return zerodevPaymaster.sponsorUserOperation({
                userOperation: _userOperation,
            });
        },
    };
};
const createKernelClientConfig = (account, bundlerRpc, chain, publicClient, paymaster) => ({
    account,
    bundlerTransport: viem.http(bundlerRpc),
    chain,
    client: publicClient,
    paymaster,
    userOperation: {
        estimateFeesPerGas: (_a) => _tslib.__awaiter(void 0, [_a], void 0, function* ({ bundlerClient }) { return actions.getUserOperationGasPrice(bundlerClient); }),
    },
});
const createEcdsaKernelAccountClient = (_b) => _tslib.__awaiter(void 0, [_b], void 0, function* ({ bundlerRpc, chain, paymasterRpc, projectId, signer, provider, paymaster = 'SPONSOR', entryPoint, kernelVersion, ecdsaValidator: ecdsaValidator$1, enableKernelV3Migration, }) {
    const resolvedBundlerRpc = bundlerRpc !== null && bundlerRpc !== void 0 ? bundlerRpc : getZeroDevBundlerRPC(projectId, provider);
    const resolvedPaymasterRpc = paymasterRpc !== null && paymasterRpc !== void 0 ? paymasterRpc : getZeroDevPaymasterRPC(projectId, provider);
    const { publicClient, zerodevPaymaster } = createPublicAndPaymasterClients(resolvedBundlerRpc, resolvedPaymasterRpc, chain);
    const validator = yield ecdsaValidator$1(publicClient, {
        entryPoint,
        kernelVersion,
        signer,
    });
    const account = yield accounts.createKernelAccount(publicClient, {
        entryPoint,
        kernelVersion,
        plugins: {
            sudo: validator,
        },
    });
    let selectedAccount = account;
    if (enableKernelV3Migration) {
        const migrationVersion = constants.KERNEL_V3_1;
        selectedAccount = yield ecdsaValidator.createEcdsaKernelMigrationAccount(publicClient, {
            entryPoint,
            migrationVersion: {
                from: kernelVersion,
                to: migrationVersion,
            },
            signer,
        });
    }
    const paymasterHandler = createPaymasterHandler(paymaster, zerodevPaymaster);
    const clientConfig = createKernelClientConfig(selectedAccount, resolvedBundlerRpc, chain, publicClient, paymasterHandler);
    return clients.createKernelAccountClient(clientConfig);
});
const createEcdsaKernelAccountClientWith7702 = (_c) => _tslib.__awaiter(void 0, [_c], void 0, function* ({ bundlerRpc, chain, paymasterRpc, projectId, signer, provider, authorization, paymaster = 'SPONSOR', entryPoint, kernelVersion, ecdsaValidator, }) {
    const resolvedBundlerRpc = bundlerRpc !== null && bundlerRpc !== void 0 ? bundlerRpc : getZeroDevBundlerRPC(projectId, provider);
    const resolvedPaymasterRpc = paymasterRpc !== null && paymasterRpc !== void 0 ? paymasterRpc : getZeroDevPaymasterRPC(projectId, provider);
    const { publicClient, zerodevPaymaster } = createPublicAndPaymasterClients(resolvedBundlerRpc, resolvedPaymasterRpc, chain);
    const validator = yield ecdsaValidator(publicClient, {
        entryPoint,
        kernelVersion,
        signer,
    });
    const account = yield accounts.createKernelAccount(publicClient, {
        address: signer.account.address,
        eip7702Auth: authorization,
        entryPoint,
        kernelVersion,
        plugins: {
            sudo: validator,
        },
    });
    const paymasterHandler = createPaymasterHandler(paymaster, zerodevPaymaster);
    const clientConfig = createKernelClientConfig(account, resolvedBundlerRpc, chain, publicClient, paymasterHandler);
    return clients.createKernelAccountClient(clientConfig);
});

exports.createEcdsaKernelAccountClient = createEcdsaKernelAccountClient;
exports.createEcdsaKernelAccountClientWith7702 = createEcdsaKernelAccountClientWith7702;
exports.getZeroDevBundlerRPC = getZeroDevBundlerRPC;
exports.getZeroDevPaymasterRPC = getZeroDevPaymasterRPC;
