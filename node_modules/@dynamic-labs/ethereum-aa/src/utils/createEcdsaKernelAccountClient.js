'use client'
import { __awaiter } from '../../_virtual/_tslib.js';
import { createKernelAccount } from '@zerodev/sdk/accounts';
import { createKernelAccountClient, createZeroDevPaymasterClient } from '@zerodev/sdk/clients';
import { getUserOperationGasPrice } from '@zerodev/sdk/actions';
import { createPublicClient, http, isAddress } from 'viem';
import { createEcdsaKernelMigrationAccount } from '@zerodev/ecdsa-validator';
import { KERNEL_V3_1 } from '@zerodev/sdk/constants';

const getZeroDevBundlerRPC = (projectId, provider) => {
    let rpc = `https://rpc.zerodev.app/api/v2/bundler/${projectId}`;
    if (provider) {
        rpc += `?bundlerProvider=${provider}`;
    }
    return rpc;
};
const getZeroDevPaymasterRPC = (projectId, provider) => {
    let rpc = `https://rpc.zerodev.app/api/v2/paymaster/${projectId}`;
    if (provider) {
        rpc += `?paymasterProvider=${provider}`;
    }
    return rpc;
};
const isERC20 = (value) => isAddress(value);
const createPublicAndPaymasterClients = (bundlerRpc, paymasterRpc, chain) => {
    const publicClient = createPublicClient({
        chain,
        transport: http(bundlerRpc),
    });
    const zerodevPaymaster = createZeroDevPaymasterClient({
        chain,
        transport: http(paymasterRpc),
    });
    return { publicClient, zerodevPaymaster };
};
const createPaymasterHandler = (paymaster, zerodevPaymaster) => {
    if (paymaster === 'NONE')
        return undefined;
    return {
        getPaymasterData: (userOperation) => {
            const _userOperation = userOperation;
            if (isERC20(paymaster)) {
                return zerodevPaymaster.sponsorUserOperation({
                    gasToken: paymaster,
                    userOperation: _userOperation,
                });
            }
            return zerodevPaymaster.sponsorUserOperation({
                userOperation: _userOperation,
            });
        },
    };
};
const createKernelClientConfig = (account, bundlerRpc, chain, publicClient, paymaster) => ({
    account,
    bundlerTransport: http(bundlerRpc),
    chain,
    client: publicClient,
    paymaster,
    userOperation: {
        estimateFeesPerGas: (_a) => __awaiter(void 0, [_a], void 0, function* ({ bundlerClient }) { return getUserOperationGasPrice(bundlerClient); }),
    },
});
const createEcdsaKernelAccountClient = (_b) => __awaiter(void 0, [_b], void 0, function* ({ bundlerRpc, chain, paymasterRpc, projectId, signer, provider, paymaster = 'SPONSOR', entryPoint, kernelVersion, ecdsaValidator, enableKernelV3Migration, }) {
    const resolvedBundlerRpc = bundlerRpc !== null && bundlerRpc !== void 0 ? bundlerRpc : getZeroDevBundlerRPC(projectId, provider);
    const resolvedPaymasterRpc = paymasterRpc !== null && paymasterRpc !== void 0 ? paymasterRpc : getZeroDevPaymasterRPC(projectId, provider);
    const { publicClient, zerodevPaymaster } = createPublicAndPaymasterClients(resolvedBundlerRpc, resolvedPaymasterRpc, chain);
    const validator = yield ecdsaValidator(publicClient, {
        entryPoint,
        kernelVersion,
        signer,
    });
    const account = yield createKernelAccount(publicClient, {
        entryPoint,
        kernelVersion,
        plugins: {
            sudo: validator,
        },
    });
    let selectedAccount = account;
    if (enableKernelV3Migration) {
        const migrationVersion = KERNEL_V3_1;
        selectedAccount = yield createEcdsaKernelMigrationAccount(publicClient, {
            entryPoint,
            migrationVersion: {
                from: kernelVersion,
                to: migrationVersion,
            },
            signer,
        });
    }
    const paymasterHandler = createPaymasterHandler(paymaster, zerodevPaymaster);
    const clientConfig = createKernelClientConfig(selectedAccount, resolvedBundlerRpc, chain, publicClient, paymasterHandler);
    return createKernelAccountClient(clientConfig);
});
const createEcdsaKernelAccountClientWith7702 = (_c) => __awaiter(void 0, [_c], void 0, function* ({ bundlerRpc, chain, paymasterRpc, projectId, signer, provider, authorization, paymaster = 'SPONSOR', entryPoint, kernelVersion, ecdsaValidator, }) {
    const resolvedBundlerRpc = bundlerRpc !== null && bundlerRpc !== void 0 ? bundlerRpc : getZeroDevBundlerRPC(projectId, provider);
    const resolvedPaymasterRpc = paymasterRpc !== null && paymasterRpc !== void 0 ? paymasterRpc : getZeroDevPaymasterRPC(projectId, provider);
    const { publicClient, zerodevPaymaster } = createPublicAndPaymasterClients(resolvedBundlerRpc, resolvedPaymasterRpc, chain);
    const validator = yield ecdsaValidator(publicClient, {
        entryPoint,
        kernelVersion,
        signer,
    });
    const account = yield createKernelAccount(publicClient, {
        address: signer.account.address,
        eip7702Auth: authorization,
        entryPoint,
        kernelVersion,
        plugins: {
            sudo: validator,
        },
    });
    const paymasterHandler = createPaymasterHandler(paymaster, zerodevPaymaster);
    const clientConfig = createKernelClientConfig(account, resolvedBundlerRpc, chain, publicClient, paymasterHandler);
    return createKernelAccountClient(clientConfig);
});

export { createEcdsaKernelAccountClient, createEcdsaKernelAccountClientWith7702, getZeroDevBundlerRPC, getZeroDevPaymasterRPC };
