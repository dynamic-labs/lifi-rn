import { KernelAccountClient } from '@zerodev/sdk/clients';
import { SmartAccount, EntryPointVersion } from 'viem/account-abstraction';
import { Client, PublicClient, RpcSchema, Transport, WalletClient } from 'viem';
import { SignAuthorizationReturnType } from 'viem/accounts';
import { type Chain as ViemChain } from 'viem/chains';
import { EntryPointType, KERNEL_VERSION_TYPE } from '@zerodev/sdk/types';
import { EthereumWallet, RegisterEvmProvidersConfig } from '@dynamic-labs/ethereum-core';
import { EcdsaValidatorOptions, Provider, ProviderEntryPointVersionEnum, ProviderEnum, ProviderKernelVersionEnum, ProviderMultichainAccountAbstractionProviders, SmartWalletProperties } from '@dynamic-labs/sdk-api-core';
import { Chain, InternalWalletConnector, IZeroDevConnector } from '@dynamic-labs/wallet-connector-core';
import { WalletBookSchema } from '@dynamic-labs/wallet-book';
import { GenericNetwork, TransactionReceipt, WalletUiUtils } from '@dynamic-labs/types';
import { AccountAbstractionBaseConnector, AccountAbstractionConnectorProps } from '@dynamic-labs/ethereum-aa-core';
import { BundlerProvider } from './utils';
type ZeroDevConnectorProps = AccountAbstractionConnectorProps & {
    apiProviders: {
        [key in ProviderEnum]?: Provider;
    };
    evmNetworks: GenericNetwork[];
    walletBook: WalletBookSchema;
    walletUiUtils: WalletUiUtils<InternalWalletConnector>;
    bundlerProvider: BundlerProvider | undefined;
    enableEIP7702?: boolean;
    authorization?: SignAuthorizationReturnType;
    providersConfig?: RegisterEvmProvidersConfig;
};
type KernelClient = KernelAccountClient<Transport, ViemChain, SmartAccount, Client, RpcSchema>;
export declare class ZeroDevConnector extends AccountAbstractionBaseConnector implements IZeroDevConnector {
    clientId: string;
    eoaConnector: InternalWalletConnector | undefined;
    eoaAddress: string | undefined;
    private providerMap;
    private eoaConnectorMap;
    ChainWallet: typeof EthereumWallet;
    connectedChain: Chain;
    supportedChains: Chain[];
    providersConfig: RegisterEvmProvidersConfig;
    isEmbeddedWallet: boolean;
    entryPoint: EntryPointType<EntryPointVersion>;
    kernelVersion: KERNEL_VERSION_TYPE;
    enableKernelV3Migration: boolean;
    ecdsaProviderType: string | undefined;
    defaultChainId: string | undefined;
    providersFromApi: ProviderMultichainAccountAbstractionProviders[];
    static bundlerProvider: BundlerProvider | undefined;
    static bundlerRpc: string | undefined;
    static paymasterRpc: string | undefined;
    static kernelDelegationAddress: `0x${string}` | undefined;
    /**
     * Deferred promise that resolves when the ZeroDev provider is set.
     * This is used to make sure that the provider is set before any other method is called.
     * This is needed because the provider is set asynchronously.
     */
    private kernelClientDeferredPromise;
    name: string;
    overrideKey: string;
    walletFallback: {
        brand: {
            alt: string;
            spriteId: string;
        };
        name: string;
    };
    enableEIP7702Mode: boolean;
    private authorization?;
    constructor(opts: ZeroDevConnectorProps);
    confirmTransactionStatus(): Promise<TransactionReceipt>;
    get currentNetworkProvider(): {
        kernelClient: KernelClient;
        kernelClientWithSponsorship: KernelClient;
    } | undefined;
    get lastUsedChainId(): string;
    get kernelClient(): KernelClient | undefined;
    get kernelClientWithSponsorship(): KernelClient | undefined;
    supportsNetworkSwitching(): boolean;
    switchNetwork({ networkChainId, }: {
        networkChainId?: number | string;
    }): Promise<void>;
    getAccountAbstractionProvider<T = KernelClient | undefined>({ withSponsorship, }?: {
        withSponsorship?: boolean;
    }): T;
    endSession(): Promise<void>;
    initialize({ smartWalletAddress, eoaAddress, eoaConnector, properties, shouldSetEoaConnector, }: {
        smartWalletAddress: string;
        eoaAddress: string;
        eoaConnector: InternalWalletConnector;
        shouldSetEoaConnector: boolean;
        properties?: SmartWalletProperties;
    }): Promise<void>;
    registerEoa({ smartWalletAddress, eoaAddress, eoaConnector, shouldSetEoaConnector, ...properties }: {
        smartWalletAddress: string;
        eoaAddress: string;
        eoaConnector: InternalWalletConnector;
        shouldSetEoaConnector: boolean;
        ecdsaProviderType?: EcdsaValidatorOptions;
        kernelVersion?: ProviderKernelVersionEnum;
        entryPointVersion?: ProviderEntryPointVersionEnum;
    }): Promise<void>;
    private getOrCreateAuthorization;
    private setEoaConnector;
    private warnIfProjectChainNotEnabled;
    /**
     * Generates a map of kernel clients for each chain in the providers list
     * Each chain gets two clients: one without sponsorship and one with sponsorship
     *
     * @param signer - The wallet client to use for signing transactions
     */
    private generateProviderMap;
    private createKernelClient;
    getAddress(): Promise<string | undefined>;
    getConnectedAccounts(): Promise<string[]>;
    getNetwork(): Promise<number | undefined>;
    private getTransport;
    getWalletClient(chainId?: string): WalletClient<Transport, ViemChain> | undefined;
    getPublicClient(): Promise<void | PublicClient<Transport, ViemChain> | undefined>;
    formatUserOperation(params: any): Promise<{
        callData: any;
        callGasLimit: `0x${string}`;
        initCode: string;
        maxFeePerGas: `0x${string}`;
        maxPriorityFeePerGas: `0x${string}`;
        nonce: `0x${string}`;
        paymasterAndData: any;
        preVerificationGas: `0x${string}`;
        sender: any;
        signature: string;
        verificationGasLimit: `0x${string}`;
        accountGasLimits?: undefined;
        gasFees?: undefined;
    } | {
        accountGasLimits: string;
        callData: any;
        gasFees: string;
        initCode: string;
        nonce: `0x${string}`;
        paymasterAndData: string;
        preVerificationGas: `0x${string}`;
        sender: any;
        signature: string;
        callGasLimit?: undefined;
        maxFeePerGas?: undefined;
        maxPriorityFeePerGas?: undefined;
        verificationGasLimit?: undefined;
    }>;
    getCurrentUserOperation(transaction: {
        from: string;
        to?: string;
        value?: bigint;
        data?: string;
    }): Promise<{
        userOperation: any;
        sponsored: boolean;
    }>;
    canSponsorTransactionGas(transaction: {
        from: string;
        to?: string;
        value?: bigint;
        data?: string;
    }): Promise<boolean>;
    getBalance(address: string): Promise<string | undefined>;
    signMessage(messageToSign: string): Promise<string | undefined>;
    validateActiveWallet(expectedAddress: string): Promise<void>;
}
export {};
