"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.watchBlockNumber = watchBlockNumber;
const getAction_js_1 = require("../utils/getAction.js");
const observe_js_1 = require("../utils/observe.js");
const poll_js_1 = require("../utils/poll.js");
const stringify_js_1 = require("../utils/stringify.js");
const getBlockCount_js_1 = require("./getBlockCount.js");
function watchBlockNumber(client, { emitOnBegin = false, emitMissed = false, onBlockNumber, onError, pollingInterval = client.pollingInterval, }) {
    let prevBlockNumber;
    const observerId = (0, stringify_js_1.stringify)([
        'watchBlockNumber',
        client.uid,
        emitOnBegin,
        emitMissed,
        pollingInterval,
    ]);
    return (0, observe_js_1.observe)(observerId, { onBlockNumber, onError }, (emit) => (0, poll_js_1.poll)(async () => {
        try {
            const blockNumber = await (0, getAction_js_1.getAction)(client, getBlockCount_js_1.getBlockCount, 'getBlockCount')({ cacheTime: 0 });
            if (prevBlockNumber) {
                if (blockNumber === prevBlockNumber) {
                    return;
                }
                if (blockNumber - prevBlockNumber > 1 && emitMissed) {
                    for (let i = prevBlockNumber + 1; i < blockNumber; i++) {
                        await emit.onBlockNumber(i, prevBlockNumber);
                        prevBlockNumber = i;
                    }
                }
            }
            if (!prevBlockNumber || blockNumber > prevBlockNumber) {
                await emit.onBlockNumber(blockNumber, prevBlockNumber);
                prevBlockNumber = blockNumber;
            }
        }
        catch (err) {
            emit.onError?.(err);
        }
    }, {
        emitOnBegin,
        interval: pollingInterval,
    }));
}
//# sourceMappingURL=watchBlockNumber.js.map