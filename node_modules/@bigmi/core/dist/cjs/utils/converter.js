"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hexToBase64 = hexToBase64;
exports.base64ToHex = base64ToHex;
exports.base64urlEncode = base64urlEncode;
exports.stringToHex = stringToHex;
exports.hexToUnit8Array = hexToUnit8Array;
function hexToBase64(hex) {
    const raw = hex
        .match(/.{1,2}/g)
        .map((byte) => String.fromCharCode(Number.parseInt(byte, 16)))
        .join('');
    return btoa(raw);
}
function base64ToHex(base64) {
    const raw = atob(base64);
    let hex = '';
    for (let i = 0; i < raw.length; i++) {
        const hexByte = raw.charCodeAt(i).toString(16);
        hex += hexByte.length === 2 ? hexByte : `0${hexByte}`;
    }
    return hex;
}
function base64urlEncode(str) {
    const bytes = new TextEncoder().encode(str);
    const encodedString = btoa(String.fromCharCode(...bytes));
    return encodedString
        .replace(/\+/g, '-')
        .replace(/\//g, '_')
        .replace(/=+$/, '');
}
function stringToHex(value) {
    const hex = Array.from(value)
        .map((char) => char.charCodeAt(0).toString(16).padStart(2, '0'))
        .join('');
    return `0x${hex}`;
}
function hexToUnit8Array(value) {
    return new Uint8Array(value.match(/.{1,2}/g)?.map((byte) => Number.parseInt(byte, 16)) || []);
}
//# sourceMappingURL=converter.js.map