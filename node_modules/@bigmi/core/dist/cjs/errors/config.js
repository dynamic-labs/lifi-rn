"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConnectorUnavailableReconnectingError = exports.ConnectorChainMismatchError = exports.ConnectorAccountNotFoundError = exports.ConnectorNotFoundError = exports.ConnectorNotConnectedError = exports.ConnectorAlreadyConnectedError = exports.ChainNotConfiguredError = void 0;
const base_js_1 = require("./base.js");
class ChainNotConfiguredError extends base_js_1.BaseError {
    constructor() {
        super('Chain not configured.');
        this.name = 'ChainNotConfiguredError';
    }
}
exports.ChainNotConfiguredError = ChainNotConfiguredError;
class ConnectorAlreadyConnectedError extends base_js_1.BaseError {
    constructor() {
        super('Connector already connected.');
        this.name = 'ConnectorAlreadyConnectedError';
    }
}
exports.ConnectorAlreadyConnectedError = ConnectorAlreadyConnectedError;
class ConnectorNotConnectedError extends base_js_1.BaseError {
    constructor() {
        super('Connector not connected.');
        this.name = 'ConnectorNotConnectedError';
    }
}
exports.ConnectorNotConnectedError = ConnectorNotConnectedError;
class ConnectorNotFoundError extends base_js_1.BaseError {
    constructor() {
        super('Connector not found.');
        this.name = 'ConnectorNotFoundError';
    }
}
exports.ConnectorNotFoundError = ConnectorNotFoundError;
class ConnectorAccountNotFoundError extends base_js_1.BaseError {
    constructor({ address, connector, }) {
        super(`Account "${address}" not found for connector "${connector}".`);
        this.name = 'ConnectorAccountNotFoundError';
    }
}
exports.ConnectorAccountNotFoundError = ConnectorAccountNotFoundError;
class ConnectorChainMismatchError extends base_js_1.BaseError {
    constructor({ connectionChainId, connectorChainId, }) {
        super(`The current chain of the connector (id: ${connectorChainId}) does not match the connection's chain (id: ${connectionChainId}).`, {
            metaMessages: [
                `Current Chain ID:  ${connectorChainId}`,
                `Expected Chain ID: ${connectionChainId}`,
            ],
        });
        this.name = 'ConnectorChainMismatchError';
    }
}
exports.ConnectorChainMismatchError = ConnectorChainMismatchError;
class ConnectorUnavailableReconnectingError extends base_js_1.BaseError {
    constructor({ connector }) {
        super(`Connector "${connector.name}" unavailable while reconnecting.`, {
            details: [
                'During the reconnection step, the only connector methods guaranteed to be available are: `id`, `name`, `type`, `uid`.',
                'All other methods are not guaranteed to be available until reconnection completes and connectors are fully restored.',
                'This error commonly occurs for connectors that asynchronously inject after reconnection has already started.',
            ].join(' '),
        });
        this.name = 'ConnectorUnavailableReconnectingError';
    }
}
exports.ConnectorUnavailableReconnectingError = ConnectorUnavailableReconnectingError;
//# sourceMappingURL=config.js.map