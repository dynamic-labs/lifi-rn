'use strict';

var getWalletProviderFromWalletAccount = require('./getWalletProviderFromWalletAccount.cjs.js');
var buffer = require('buffer');
require('@dynamic-labs/sdk-api-core');

class MethodNotImplementedError extends getWalletProviderFromWalletAccount.BaseError {
    constructor(methodName){
        super({
            cause: null,
            code: 'method_not_implemented_error',
            docsUrl: null,
            name: 'MethodNotImplementedError',
            shortMessage: `This method is not implemented: ${methodName}`
        });
    }
}

/**
 * Registers an extension to the client.
 *
 * Other extensions can be aware of which extensions are present,
 * and allows creating dependencies between extensions.
 *
 * @param client - The client instance.
 * @param extensionKey - The key of the extension to register.
 * @returns The client instance.
 */ const registerExtension = (client, extensionKey)=>{
    const core = getWalletProviderFromWalletAccount.getCore(client);
    core.extensions.add(extensionKey);
};

/**
 * Formats a sign in message to prove ownership of an address.
 */ const formatSignInMessage = async ({ domain, blockchainName, address, uri, chainId, nonce, issuedAt, requestId, statement, resources })=>{
    // This format follows the sign-in with ethereum (SIWE) standard,
    // but we are using it also for non-ethereum wallets for now (eg. Solana)
    // for more context on format and fields, please see:
    // https://docs.login.xyz/general-information/siwe-overview/eip-4361
    const header = `${domain} wants you to sign in with your ${blockchainName} account:`;
    const prefix = [
        header,
        address
    ].join('\n');
    // If there is a statement, we want to add a gap between the prefix and the statement
    // two times '\n', first to move statement to next line and second to add a gap between prefix and statement
    const prefixWithStatementGap = statement ? '\n\n' : '\n';
    const prefixWithStatement = `${[
        prefix,
        statement
    ].join(prefixWithStatementGap)}\n`;
    const suffixFields = [];
    suffixFields.push(`URI: ${uri}`);
    suffixFields.push('Version: 1');
    if (chainId) {
        suffixFields.push(`Chain ID: ${chainId}`);
    }
    suffixFields.push(`Nonce: ${nonce}`);
    suffixFields.push(`Issued At: ${issuedAt}`);
    if (requestId) {
        suffixFields.push(`Request ID: ${requestId}`);
    }
    if (resources == null ? void 0 : resources.length) {
        suffixFields.push(`Resources:${resources.map((resource)=>'\n- ' + resource).join()}`);
    }
    const suffix = suffixFields.join('\n');
    return [
        prefixWithStatement,
        suffix
    ].join('\n');
};

const formatWalletProviderGroupKey = (walletName)=>walletName.replace(/[^a-zA-Z0-9]/g, '').toLowerCase();

/**
 * Format the wallet name and chain to get a wallet provider key.
 */ const formatWalletProviderKey = (walletName, chain)=>{
    const sanitizedWalletName = walletName.replace(/[^a-zA-Z0-9]/g, '').toLowerCase();
    return `${sanitizedWalletName}${chain.toLocaleLowerCase()}`;
};

// eslint-disable-next-line no-restricted-globals
const getBuffer = ()=>Buffer != null ? Buffer : buffer.Buffer;

const bufferToBase64 = (buf)=>{
    const binstr = Array.prototype.map.call(buf, (ch)=>String.fromCharCode(ch)).join('');
    return getBuffer().from(binstr, 'binary').toString('base64');
};

exports.APIError = getWalletProviderFromWalletAccount.APIError;
exports.CannotTrackError = getWalletProviderFromWalletAccount.CannotTrackError;
exports.ClientNotPresentError = getWalletProviderFromWalletAccount.ClientNotPresentError;
exports.ClientsDoNotMatchError = getWalletProviderFromWalletAccount.ClientsDoNotMatchError;
exports.InvalidStorageSet = getWalletProviderFromWalletAccount.InvalidStorageSet;
exports.ValueMustBeDefinedError = getWalletProviderFromWalletAccount.ValueMustBeDefinedError;
Object.defineProperty(exports, "WalletProviderPriority", {
  enumerable: true,
  get: function () { return getWalletProviderFromWalletAccount.WalletProviderPriority; }
});
exports.assertDefined = getWalletProviderFromWalletAccount.assertDefined;
exports.assignClient = getWalletProviderFromWalletAccount.assignClient;
exports.createApiClient = getWalletProviderFromWalletAccount.createApiClient;
exports.emitEvent = getWalletProviderFromWalletAccount.emitEvent;
exports.getClient = getWalletProviderFromWalletAccount.getClient;
exports.getCore = getWalletProviderFromWalletAccount.getCore;
exports.getWalletProviderFromWalletAccount = getWalletProviderFromWalletAccount.getWalletProviderFromWalletAccount;
exports.getWalletProviderRegistry = getWalletProviderFromWalletAccount.getWalletProviderRegistry;
exports.hasExtension = getWalletProviderFromWalletAccount.hasExtension;
exports.subscribeWithSelector = getWalletProviderFromWalletAccount.subscribeWithSelector;
exports.MethodNotImplementedError = MethodNotImplementedError;
exports.bufferToBase64 = bufferToBase64;
exports.formatSignInMessage = formatSignInMessage;
exports.formatWalletProviderGroupKey = formatWalletProviderGroupKey;
exports.formatWalletProviderKey = formatWalletProviderKey;
exports.registerExtension = registerExtension;
