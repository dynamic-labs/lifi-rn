import { AuthStorageEnum, SDKApi, Configuration } from '@dynamic-labs/sdk-api-core';

const getCore = (client)=>{
    // @ts-expect-error - this was hidden from the public API
    return client.__core;
};

/**
 * Shallow compare two objects.
 *
 * Source: https://github.com/pmndrs/zustand/blob/main/src/vanilla/shallow.ts
 */ const isEqualShallow = (objA, objB)=>{
    if (Object.is(objA, objB)) return true;
    if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
        return objA === objB;
    }
    if (objA instanceof Map && objB instanceof Map) {
        if (objA.size !== objB.size) return false;
        for (const [key, value] of objA){
            if (!Object.is(value, objB.get(key))) return false;
        }
        return true;
    }
    if (objA instanceof Set && objB instanceof Set) {
        if (objA.size !== objB.size) return false;
        for (const value of objA){
            if (!objB.has(value)) return false;
        }
        return true;
    }
    const keysA = Object.keys(objA);
    if (keysA.length !== Object.keys(objB).length) return false;
    for (const keyA of keysA){
        if (!Object.prototype.hasOwnProperty.call(objB, keyA) || !Object.is(objA[keyA], objB[keyA])) {
            return false;
        }
    }
    if (objA.constructor !== objB.constructor) return false;
    return true;
};

/**
 * Allows subscribing to a slice of the state.
 * The slice is a computation of the states.
 *
 * The callback will only be called when the slice has changed.
 * Change is determined by shallow comparison.
 *
 * Returns a function to unsubscribe the callback.
 */ const subscribeWithSelector = (observable, selector)=>(callback)=>{
        let lastSlice = selector(observable.get());
        return observable.subscribe((value)=>{
            const nextSlice = selector(value);
            if (isEqualShallow(nextSlice, lastSlice)) return;
            lastSlice = nextSlice;
            callback(nextSlice);
        });
    };

function _extends() {
    _extends = Object.assign || function assign(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source)if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
        }
        return target;
    };
    return _extends.apply(this, arguments);
}

var version = "0.0.1-alpha.19";
var dependencies = {
    "@dynamic-labs/sdk-api-core": "0.0.727"};

const randomString = (length)=>{
    const CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_';
    let result = '';
    for(let i = length; i > 0; --i){
        result += CHARS[Math.floor(Math.random() * CHARS.length)];
    }
    return result;
};

const getDetails = ({ details, cause })=>{
    if (cause instanceof BaseError) {
        return cause.details;
    }
    if (cause == null ? void 0 : cause.message) {
        return cause.message;
    }
    return details;
};
/**
 * Formats the error message with all available information
 */ const formatMessage = ({ shortMessage, details, docsUrl, metaMessages })=>{
    return [
        shortMessage,
        '',
        ...metaMessages ? [
            ...metaMessages,
            ''
        ] : [],
        ...docsUrl ? [
            `Docs: ${docsUrl}`
        ] : [],
        ...details ? [
            `Details: ${details}`
        ] : [],
        `Version: ${version}`,
        `Timestamp: ${new Date().toISOString()}`
    ].join('\n');
};
/**
 * Base error class that provides structured error handling with detailed information
 */ class BaseError extends Error {
    /**
   * Walks the cause chain of the error and returns the root error
   */ walk() {
        const cause = this.cause;
        if (cause instanceof BaseError) {
            return cause.walk();
        }
        return cause;
    }
    toString() {
        return this.formattedMessage;
    }
    constructor(args){
        const details = getDetails(args);
        const formattedMessage = formatMessage(_extends({}, args, {
            details
        }));
        var _args_shortMessage;
        super((_args_shortMessage = args.shortMessage) != null ? _args_shortMessage : formattedMessage, args.cause ? {
            cause: args.cause
        } : undefined);
        this.name = 'BaseError';
        this.formattedMessage = formattedMessage;
        this.details = details;
        var _args_name;
        this.name = (_args_name = args.name) != null ? _args_name : this.name;
        var _args_cause;
        this.cause = (_args_cause = args.cause) != null ? _args_cause : this.cause;
        this.code = args.code;
    }
}

class ValueMustBeDefinedError extends BaseError {
    constructor(message){
        super({
            cause: null,
            code: 'value_must_be_defined_error',
            docsUrl: null,
            name: 'ValueMustBeDefined',
            shortMessage: message
        });
    }
}

/**
 * Asserts that a value is not null or undefined, throwing an error if it is.
 * This function acts as a type guard, narrowing the type to exclude null and undefined.
 *
 * @template T - The type of the value being checked
 * @param value - The value to check for null or undefined
 * @param message - The error message to throw if the value is null or undefined
 * @throws Throws an error with the provided message if value is null or undefined
 * @example
 * ```typescript
 * const maybeString: string | null = getValue();
 * assertDefined(maybeString, 'String value is required');
 * // maybeString is now typed as string (null is excluded)
 * ```
 */ function assertDefined(value, message) {
    if (value === null || value === undefined) {
        throw new ValueMustBeDefinedError(message);
    }
}

/**
 * Returns true if the client is using Dynamic cookies or a BYO JWT cookie.
 */ const isCookieEnabled = (client)=>{
    var _securitySettings_auth, _securitySettings_externalAuth;
    assertDefined(client.projectSettings, 'Project settings are not defined');
    const securitySettings = client.projectSettings.security;
    if (!securitySettings) return false;
    // client uses Dynamic cookies
    const dynamicCookiesEnabled = (((_securitySettings_auth = securitySettings.auth) == null ? void 0 : _securitySettings_auth.storage) || []).includes(AuthStorageEnum.Cookie);
    // BYO JWT client puts their non-Dynamic JWT in a cookie
    const byoJwtCookieEnabled = Boolean((_securitySettings_externalAuth = securitySettings.externalAuth) == null ? void 0 : _securitySettings_externalAuth.cookieName);
    // should return true for both of these scenarios
    // because we also need to do `credentials: true` in api.ts when
    // a byo jwt client sets their named cookie for their jwt and
    // needs to send it to our backend
    return dynamicCookiesEnabled || byoJwtCookieEnabled;
};

const DYNAMIC_API_VERSION_HEADER = 'x-dyn-api-version';
const DYNAMIC_REQUEST_ID_HEADER = 'x-dyn-request-id';
const DYNAMIC_SDK_VERSION_HEADER = 'x-dyn-version';
const MFA_TOKEN_HEADER = 'x-mfa-auth-token';

class APIError extends BaseError {
    static async fromResponse(response) {
        const errorBody = await response.json();
        if ('code' in errorBody && typeof errorBody.code === 'string' && 'error' in errorBody && typeof errorBody.error === 'string') {
            return new APIError(errorBody.error, errorBody.code);
        }
        return null;
    }
    constructor(message, code){
        super({
            cause: null,
            code,
            docsUrl: null,
            name: 'APIError',
            shortMessage: message
        });
    }
}

class MfaInvalidOtpError extends BaseError {
    constructor({ cause }){
        super({
            cause,
            code: 'mfa_invalid_otp_error',
            docsUrl: null,
            name: 'MfaInvalidOtpError',
            shortMessage: 'Invalid OTP'
        });
    }
}

class MfaRateLimitedError extends BaseError {
    constructor({ cause }){
        super({
            cause,
            code: 'mfa_rate_limited_error',
            docsUrl: null,
            name: 'MfaRateLimitedError',
            shortMessage: 'Rate limited'
        });
    }
}

/**
 * Default error mapper for the client that handles common API error codes.
 *
 * This mapper transforms specific API error codes into more specific error types:
 * - `mfa_invalid_code` → `MfaInvalidOtpError`
 * - `mfa_rate_limited` → `MfaRateLimitedError`
 *
 * @param error - The error to be mapped
 * @returns A transformed error if the error code matches a known pattern, or null if no transformation is needed
 *
 * @example
 * ```typescript
 * // This will be automatically applied to all API errors
 * const apiClient = createApiClient(client);
 *
 * // The clientErrorMapper will automatically convert mfa_invalid_code errors
 * // to MfaInvalidOtpError instances
 * ```
 */ const clientErrorMapper = (error)=>{
    if (error instanceof APIError) {
        if (error.code === 'mfa_invalid_code') {
            return new MfaInvalidOtpError({
                cause: error
            });
        }
        if (error.code === 'mfa_rate_limited') {
            return new MfaRateLimitedError({
                cause: error
            });
        }
    }
    return null;
};

/**
 * Creates middleware that converts HTTP error responses to APIError instances
 * and optionally applies custom error mappers to transform them into specific error types.
 *
 * @param options.errorMappers - Array of error mappers to apply to API errors
 * @returns A middleware function that handles error conversion and mapping
 */ const createConvertToApiErrorMiddleware = ({ errorMappers = [] })=>({
        post: async (context)=>{
            if (context.response.status >= 400) {
                const apiError = await APIError.fromResponse(context.response);
                if (apiError) {
                    let errorToThrow = apiError;
                    for (const mapper of errorMappers){
                        const newError = mapper(apiError);
                        if (newError) {
                            errorToThrow = newError;
                            break;
                        }
                    }
                    throw errorToThrow;
                }
            }
            return context.response;
        }
    });

/**
 * Returns a new instance of the SDK API client.
 *
 * This is not meant for storing, as it is very light we can create it whenever needed.
 */ const createApiClient = (client, options = {})=>{
    const core = getCore(client);
    const coreState = core.state.get();
    const settings = {
        basePath: core.apiBaseUrl,
        headers: _extends({
            'Content-Type': 'application/json',
            [DYNAMIC_API_VERSION_HEADER]: dependencies['@dynamic-labs/sdk-api-core'],
            [DYNAMIC_REQUEST_ID_HEADER]: randomString(50),
            /**
       * Ticket revise API version
       */ [DYNAMIC_SDK_VERSION_HEADER]: 'WalletKit/4.22.5'
        }, core.getApiHeaders())
    };
    if (client.token) {
        settings.headers.Authorization = `Bearer ${client.token}`;
    }
    if (client.projectSettings && isCookieEnabled(client)) {
        settings.credentials = 'include';
    }
    if (options.includeMfaToken && coreState.mfaToken) {
        settings.headers[MFA_TOKEN_HEADER] = coreState.mfaToken;
    }
    return new SDKApi(new Configuration(_extends({}, settings, {
        fetchApi: core.fetch,
        middleware: [
            createConvertToApiErrorMiddleware({
                errorMappers: [
                    ...options.errorMappers || [],
                    clientErrorMapper
                ]
            })
        ]
    })));
};

/**
 * Listen to an event from the client.
 *
 * @returns A function that can be called to remove the listener.
 */ const onEvent = (client, event, listener)=>{
    const { eventEmitter } = getCore(client);
    eventEmitter.on(event, listener);
    return ()=>{
        eventEmitter.off(event, listener);
    };
};
/**
 * Remove a listener from an event.
 */ const offEvent = (client, event, listener)=>{
    const { eventEmitter } = getCore(client);
    eventEmitter.off(event, listener);
};
/**
 * Listen to an event that will only fire once.
 *
 * @returns A function that can be called to remove the listener.
 */ const onceEvent = (client, event, listener)=>{
    const { eventEmitter } = getCore(client);
    eventEmitter.once(event, listener);
    return ()=>{
        eventEmitter.off(event, listener);
    };
};
/**
 * Emit an event.
 */ const emitEvent = (client, event, ...args)=>{
    const { eventEmitter } = getCore(client);
    eventEmitter.emit(event, ...args);
};

const assignClient = (target, client)=>{
    Object.defineProperty(target, '__client', {
        // hide from enumeration
        configurable: true,
        enumerable: false,
        get: ()=>client
    });
    return target;
};

class ClientNotPresentError extends BaseError {
    constructor(){
        super({
            cause: null,
            code: 'client_not_present_error',
            docsUrl: null,
            name: 'ClientNotPresentError',
            shortMessage: 'The client is not present in the target object.'
        });
    }
}

const getClient = (target)=>{
    if (!Object.prototype.hasOwnProperty.call(target, '__client')) {
        throw new ClientNotPresentError();
    }
    // @ts-expect-error - this was hidden from the public API
    return target.__client;
};

class InvalidStorageSet extends BaseError {
    constructor({ key, value }){
        super({
            cause: null,
            code: 'invalid_storage_set',
            docsUrl: null,
            metaMessages: [
                `key: ${key}`,
                value
            ],
            name: 'InvalidStorageSet',
            shortMessage: 'Tried to store a value that does not match the schema'
        });
    }
}

class CannotTrackError extends BaseError {
    constructor(){
        super({
            cause: null,
            code: 'cannot_track_error',
            docsUrl: null,
            name: 'CannotTrackError',
            shortMessage: 'All track calls must be performed in the same node tick'
        });
    }
}

/**
 * Creates a service accessor function that manages service instantiation and caching.
 * The returned function will either retrieve an existing service from the registry or
 * create a new one using the provided builder function.
 *
 * @template - The type of service to be created/accessed
 * @param key - Unique identifier for the service in the registry
 * @param builder - Function that creates the service instance when called with a DynamicClient
 */ const createRuntimeServiceAccessKey = (key, builder)=>(client)=>{
        const { runtimeServices } = getCore(client);
        const currentService = runtimeServices.getByKey(key);
        if (currentService) {
            return currentService;
        }
        const service = builder(client);
        runtimeServices.register(key, service);
        return service;
    };

/**
 * Checks if an extension has been applied to the client.
 */ const hasExtension = (client, extensionKey)=>{
    const core = getCore(client);
    return core.extensions.has(extensionKey);
};

class ClientsDoNotMatchError extends BaseError {
    constructor(){
        super({
            cause: null,
            code: 'clients_do_not_match_error',
            docsUrl: null,
            name: 'ClientsDoNotMatchError',
            shortMessage: 'Clients do not match'
        });
    }
}

const assertClientAreEqual = (client1, client2)=>{
    if (client1 !== client2) {
        throw new ClientsDoNotMatchError();
    }
};

/**
 * Creates a new wallet provider registry that manages wallet providers with priority-based registration.
 *
 * @returns The wallet provider registry instance
 *
 * @example
 * ```typescript
 * const registry = createWalletProviderRegistry();
 *
 * registry.register({
 *   priority: WalletProviderPriority.WALLET_SDK,
 *   walletProvider: myWalletProvider
 * });
 *
 * const provider = registry.getByKey('my-wallet-key');
 * const providers = registry.listProviders();
 * ```
 */ const createWalletProviderRegistry = (client)=>{
    const core = getCore(client);
    const registry = new Map();
    return {
        getByKey: (key)=>{
            var _registry_get;
            return (_registry_get = registry.get(key)) == null ? void 0 : _registry_get.walletProvider;
        },
        listProviders: ()=>Array.from(registry.values()).map((v)=>v.walletProvider),
        register: (args)=>{
            /**
       * Verify the wallet provider has the client assigned to it
       */ assertClientAreEqual(getClient(args.walletProvider), client);
            const existingEntry = registry.get(args.walletProvider.key);
            if (existingEntry) {
                if (existingEntry.priority < args.priority) {
                    registry.set(args.walletProvider.key, args);
                    core.eventEmitter.emit('walletProviderChanged', args.walletProvider.key);
                }
            } else {
                registry.set(args.walletProvider.key, args);
                core.eventEmitter.emit('walletProviderRegistered', args.walletProvider);
                core.eventEmitter.emit('walletProviderChanged', args.walletProvider.key);
            }
        }
    };
};

/**
 * This function provides access to a shared instance of the wallet provider registry.
 *
 * It ensures that the same registry instance is used throughout the client to maintaining
 * consistency of registered wallet providers across different parts of the codebase.
 *
 * @returns The wallet provider registry instance
 *
 * @example
 * ```typescript
 * // Get the registry instance
 * const registry = getWalletProviderRegistry();
 *
 * // Register a wallet provider
 * registry.register({
 *   priority: WalletProviderPriority.WALLET_SDK,
 *   walletProvider: myWalletProvider
 * });
 *
 * // Retrieve a specific provider
 * const provider = registry.getByKey('metamask');
 * ```
 */ const getWalletProviderRegistry = createRuntimeServiceAccessKey('walletProviderRegistry', (client)=>createWalletProviderRegistry(client));

var WalletProviderPriority;
(function(WalletProviderPriority) {
    /**
   * Highest priority should be used by wallet providers that implement
   * the most reliable wallet integration.
   * example: The SDK provided by the wallet provider.
   */ WalletProviderPriority[WalletProviderPriority["WALLET_SDK"] = 100] = "WALLET_SDK";
    /**
   * Medium priority should be used by wallet providers that implement
   * a wallet integration via some reliable standard.
   * example: A wallet provider that uses EIP6963 announcement.
   */ WalletProviderPriority[WalletProviderPriority["WALLET_SELF_ANNOUNCEMENT_STANDARD"] = 50] = "WALLET_SELF_ANNOUNCEMENT_STANDARD";
    /**
   * Low priority should be used by wallet providers that implement
   * a wallet integration on a less reliable standard.
   * example: A wallet provider that uses window.ethereum, where the
   * window key can be overridden by other extensions.
   */ WalletProviderPriority[WalletProviderPriority["WINDOW_INJECT"] = 20] = "WINDOW_INJECT";
})(WalletProviderPriority || (WalletProviderPriority = {}));

const getWalletProviderFromWalletAccount = (walletAccount)=>{
    const client = getClient(walletAccount);
    const walletProviderRegistry = getWalletProviderRegistry(client);
    const walletProvider = walletProviderRegistry.getByKey(walletAccount.walletProviderKey);
    assertDefined(walletProvider, `Wallet provider "${walletAccount.walletProviderKey}" not found`);
    return walletProvider;
};

export { APIError as A, BaseError as B, CannotTrackError as C, InvalidStorageSet as I, MfaInvalidOtpError as M, ValueMustBeDefinedError as V, WalletProviderPriority as W, _extends as _, assertDefined as a, assignClient as b, createApiClient as c, dependencies as d, emitEvent as e, getClient as f, getCore as g, getWalletProviderFromWalletAccount as h, isEqualShallow as i, getWalletProviderRegistry as j, MfaRateLimitedError as k, onceEvent as l, onEvent as m, hasExtension as n, offEvent as o, ClientNotPresentError as p, ClientsDoNotMatchError as q, randomString as r, subscribeWithSelector as s, version as v };
