'use strict';

var getWalletProviderFromWalletAccount = require('./getWalletProviderFromWalletAccount.cjs.js');
var sdkApiCore = require('@dynamic-labs/sdk-api-core');
var z = require('@zod/mini');
var EventEmitter = require('eventemitter3');
var browser = require('@simplewebauthn/browser');

function _interopNamespaceDefault(e) {
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var z__namespace = /*#__PURE__*/_interopNamespaceDefault(z);

/**
 * Maps the state keys to the event names.
 *
 * This is mainly to ensure that whenever a new state key is added, the developer
 * will have to come to this file and remember to add it here and in the interface.
 */ const stateChangeEvents = {
    initStatus: 'initStatusChanged',
    mfaToken: 'mfaTokenChanged',
    projectSettings: 'projectSettingsChanged',
    token: 'tokenChanged',
    user: 'userChanged'
};

/**
 * This error is thrown when the `retryOnFail` function is called with an invalid
 * number of retries (i.e. less than 0).
 */ class InvalidRetryOnFailCallError extends getWalletProviderFromWalletAccount.BaseError {
    constructor(maxRetries){
        super({
            cause: null,
            code: 'invalid_retry_on_fail_call_error',
            docsUrl: null,
            name: 'InvalidRetryOnFailCallError',
            shortMessage: `Invalid retries parameter for retryOnFail call: ${maxRetries}`
        });
    }
}

const retryOnFail = async ({ delay = 0, fn, maxRetries })=>{
    for(let retry = 0; retry <= maxRetries; retry++){
        try {
            return await fn();
        } catch (error) {
            if (retry >= maxRetries) {
                throw error;
            }
            if (delay > 0) {
                await new Promise((resolve)=>setTimeout(resolve, delay));
            }
        }
    }
    throw new InvalidRetryOnFailCallError(maxRetries);
};

const mapVerifiedCredentialChainToChain = (verifiedCredentialChain)=>{
    const mapVerifiedChainIdToChain = {
        algorand: 'ALGO',
        bip122: 'BTC',
        cosmos: 'COSMOS',
        eclipse: 'ECLIPSE',
        eip155: 'EVM',
        flow: 'FLOW',
        solana: 'SOL',
        starknet: 'STARK'
    };
    const chain = mapVerifiedChainIdToChain[verifiedCredentialChain];
    getWalletProviderFromWalletAccount.assertDefined(chain, `Unknown chain: ${verifiedCredentialChain}`);
    return chain;
};

const normalizeAddress = (address, chain)=>{
    let normalizedAddress = address;
    if (normalizedAddress == null ? void 0 : normalizedAddress.startsWith('0x')) {
        normalizedAddress = normalizedAddress.slice(2);
    }
    /**
   * These are standard from CAIP-2: https://github.com/ChainAgnostic/CAIPs/blob/master/CAIPs/caip-2.md
   * see also: https://github.com/ChainAgnostic/namespaces
   * note: no standard namespace currently exists for flow
   */ const chainsThatRequireLowercaseAddress = [
        'EVM',
        'FLOW'
    ];
    normalizedAddress = chainsThatRequireLowercaseAddress.includes(chain) ? normalizedAddress == null ? void 0 : normalizedAddress.toLowerCase() : normalizedAddress;
    return normalizedAddress;
};

const createWalletAccountId = (chain, address)=>`${chain}-${normalizeAddress(address, chain)}`;

const convertVerifiedCredentialToWalletAccount = (verified)=>{
    getWalletProviderFromWalletAccount.assertDefined(verified.address, 'Missing address in verified credential');
    getWalletProviderFromWalletAccount.assertDefined(verified.chain, 'Missing chain in verified credential');
    getWalletProviderFromWalletAccount.assertDefined(verified.walletName, 'Missing wallet name in verified credential');
    const chain = mapVerifiedCredentialChainToChain(verified.chain);
    var _verified_lastSelectedAt;
    return {
        address: verified.address,
        chain,
        id: createWalletAccountId(chain, verified.address),
        lastSelectedAt: (_verified_lastSelectedAt = verified.lastSelectedAt) != null ? _verified_lastSelectedAt : null,
        verifiedCredentialId: verified.id,
        walletProviderKey: verified.walletName
    };
};

const convertUnverifiedWalletAccountToWalletAccount = (unverifiedWalletAccount)=>({
        address: unverifiedWalletAccount.address,
        chain: unverifiedWalletAccount.chain,
        id: createWalletAccountId(unverifiedWalletAccount.chain, unverifiedWalletAccount.address),
        lastSelectedAt: unverifiedWalletAccount.lastSelectedAt,
        verifiedCredentialId: null,
        walletProviderKey: unverifiedWalletAccount.walletProviderKey
    });

/**
 * Retrieves all wallet accounts associated with the current user from the Dynamic client.
 *
 * @param client - The Dynamic client instance
 * @returns An array of wallet accounts
 */ const getWalletAccounts = (client)=>{
    const core = getWalletProviderFromWalletAccount.getCore(client);
    const { unverifiedWalletAccounts, user } = core.state.get();
    const walletAccountsMap = new Map();
    /**
   * Handle the unverified wallet accounts before the user verified credentials
   * so the later veririfed wallet accounts can override the unverified wallet accounts
   */ unverifiedWalletAccounts.forEach((unverifiedWalletAccount)=>{
        const walletAccount = convertUnverifiedWalletAccountToWalletAccount(unverifiedWalletAccount);
        walletAccountsMap.set(walletAccount.id, walletAccount);
    });
    var _user_verifiedCredentials;
    /**
   * Handle user verified credentials
   */ const verifiedCredentials = (_user_verifiedCredentials = user == null ? void 0 : user.verifiedCredentials) != null ? _user_verifiedCredentials : [];
    verifiedCredentials.filter((verified)=>verified.format === sdkApiCore.JwtVerifiedCredentialFormatEnum.Blockchain).map(convertVerifiedCredentialToWalletAccount).forEach((veririedWalletAccount)=>walletAccountsMap.set(veririedWalletAccount.id, veririedWalletAccount));
    return Array.from(walletAccountsMap.values()).map((walletAccount)=>getWalletProviderFromWalletAccount.assignClient(walletAccount, client));
};

/**
 * The client is considered to be in a signed in state if a user has
 * authenticated, or client has at least one wallet connected.
 */ const isSignedIn = (client)=>Boolean(client.user || getWalletAccounts(client).length > 0);

const createStorageKeySchema = (params)=>{
    return params;
};

/**
 * Returns whether the given string is a valid ISO date string.
 *
 * Does not support timezone offsets.
 */ const isValidDateISOString = (value)=>{
    const date = new Date(value);
    return !isNaN(date.getTime()) && date.toISOString() === value;
};

const DATE_PREFIX = '__DATE__';
const formatForStorage = (value)=>{
    const item = {
        value
    };
    return JSON.stringify(item, (_, entry)=>{
        // You might think that entry here would be a Date and one could simply do "entry instanceof Date",
        // but actually it will be a string already (no idea why JSON.stringify does this)
        if (isValidDateISOString(entry)) {
            return `${DATE_PREFIX}${entry}`;
        }
        return entry;
    });
};
const parseFromStorage = (value)=>{
    try {
        const parsed = JSON.parse(value, (_, entry)=>{
            if (typeof entry === 'string' && entry.startsWith(DATE_PREFIX)) {
                return new Date(entry.slice(DATE_PREFIX.length));
            }
            return entry;
        });
        return parsed;
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    } catch (error) {
        return null;
    }
};

/**
 * Creates a Storage instance that uses localStorage as the storage model meant for use in the browser.
 */ const createWebStorage = ({ prefix = '' } = {})=>{
    const getPrefixedKey = (key)=>prefix ? `${prefix}_${key}` : key;
    return {
        getItem: async (storageKeySchema)=>{
            const rawItem = localStorage.getItem(getPrefixedKey(storageKeySchema.key));
            const parsedItem = rawItem ? parseFromStorage(rawItem) : null;
            /**
       * The item saved to localStorage may be malformed.
       * In this case, we remove it and return null.
       */ if (parsedItem !== null) {
                const parsed = storageKeySchema.schema.safeParse(parsedItem.value);
                if (parsed.success) {
                    return parsed.data;
                }
            }
            /**
       * The item saved to localStorage may be malformed.
       * In this case, we remove it and return null.
       */ localStorage.removeItem(getPrefixedKey(storageKeySchema.key));
            return null;
        },
        removeItem: async (storageKeySchema)=>{
            localStorage.removeItem(getPrefixedKey(storageKeySchema.key));
        },
        setItem: async (storageKeySchema, value)=>{
            const parsed = storageKeySchema.schema.safeParse(value);
            if (!parsed.success) {
                throw new getWalletProviderFromWalletAccount.InvalidStorageSet({
                    key: storageKeySchema.key,
                    value: JSON.stringify(value)
                });
            }
            const item = formatForStorage(parsed.data);
            localStorage.setItem(getPrefixedKey(storageKeySchema.key), item);
        }
    };
};

/**
 * The schema to track the expiration time of the project settings.
 */ const projectSettingsExpirationScheme = createStorageKeySchema({
    key: 'projectSettingsExpiration',
    schema: z__namespace.number()
});

/**
 * Expiration time of the project settings in milliseconds.
 */ const PROJECT_SETTINGS_EXPIRATION_TIME = 1000 * 60 * 5; // 5 minutes
/**
 * Updates the project settings in the core state to the latest values.
 */ const fetchProjectSettings = async (client)=>{
    const core = getWalletProviderFromWalletAccount.getCore(client);
    const currentExpiration = await core.storage.getItem(projectSettingsExpirationScheme);
    const hasProjectSettings = Boolean(client.projectSettings);
    const isExpired = currentExpiration && currentExpiration < Date.now();
    // We want to cache the project settings if its valid and user is connected.
    // This avoids unnecessary API calls and speeds up the initial load.
    if (hasProjectSettings && !isExpired && isSignedIn(client)) {
        return client.projectSettings;
    }
    const apiClient = getWalletProviderFromWalletAccount.createApiClient(client);
    const doFetch = async ()=>apiClient.getEnvironmentSettings({
            environmentId: core.environmentId,
            sdkVersion: `WalletKit/${core.version}`
        }, {
            credentials: 'omit'
        });
    const projectSettings = await retryOnFail({
        fn: doFetch,
        maxRetries: 2
    });
    core.state.set({
        projectSettings: projectSettings != null ? projectSettings : null
    });
    await core.storage.setItem(projectSettingsExpirationScheme, Date.now() + PROJECT_SETTINGS_EXPIRATION_TIME);
    return projectSettings;
};

const logout = async (client)=>{
    const core = getWalletProviderFromWalletAccount.getCore(client);
    const apiClient = getWalletProviderFromWalletAccount.createApiClient(client);
    try {
        await apiClient.revokeSession({
            environmentId: core.environmentId
        });
    } catch (error) {
        core.logger.error('Failed to revoke session', error);
    }
    core.state.set({
        sessionExpiresAt: null,
        token: null,
        user: null
    });
    getWalletProviderFromWalletAccount.emitEvent(client, 'logout');
    // Refetch project settings
    void fetchProjectSettings(client);
};

/**
 * A replacement for setTimeout that supports delays longer than 2147483647ms (~24.8 days).
 */ const setLongTimeout = (callback, delay)=>{
    const MAX_DELAY = 2147483647; // Maximum delay for setTimeout (2^31 - 1)
    let timeoutId = null;
    let remaining = delay;
    const run = ()=>{
        if (remaining <= MAX_DELAY) {
            timeoutId = setTimeout(callback, remaining);
        } else {
            timeoutId = setTimeout(()=>{
                remaining -= MAX_DELAY;
                run();
            }, MAX_DELAY);
        }
    };
    run();
    // Return a cancel function
    return ()=>{
        if (timeoutId !== null) {
            clearTimeout(timeoutId);
        }
    };
};

/**
 * Sets up a timeout to log out the user when their token expires.
 */ const initializeAuth = (client)=>{
    const core = getWalletProviderFromWalletAccount.getCore(client);
    let clearExpirationTimeout = null;
    const onChangeExpiration = getWalletProviderFromWalletAccount.subscribeWithSelector(core.state, (state)=>state.sessionExpiresAt);
    const checkExpiration = ()=>{
        const expiration = core.state.get().sessionExpiresAt;
        clearExpirationTimeout == null ? void 0 : clearExpirationTimeout();
        if (!expiration) {
            return;
        }
        const now = new Date();
        const timeUntilExpiration = expiration.getTime() - now.getTime();
        if (timeUntilExpiration <= 0) {
            void logout(client);
            return;
        }
        // Wait for token expiration
        clearExpirationTimeout = setLongTimeout(checkExpiration, timeUntilExpiration);
    };
    onChangeExpiration(checkExpiration);
    checkExpiration();
};

const raiseStateEvents = (client)=>{
    const core = getWalletProviderFromWalletAccount.getCore(client);
    core.state.subscribe((value, previous)=>{
        const eventEntries = Object.entries(stateChangeEvents);
        eventEntries.forEach(([key, event])=>{
            // Check if this key had a change
            if (getWalletProviderFromWalletAccount.isEqualShallow(value[key], previous[key])) return;
            core.eventEmitter.emit(event, value[key], previous[key]);
        });
    });
};

const SDK_API_CORE_VERSION = getWalletProviderFromWalletAccount.dependencies['@dynamic-labs/sdk-api-core'];

const stateStorageKeySchema = createStorageKeySchema({
    key: 'state',
    schema: z__namespace.object({
        apiVersion: z__namespace.string(),
        projectSettings: z__namespace.custom(),
        user: z__namespace.custom()
    })
});
const sessionKeySchema = createStorageKeySchema({
    key: 'session',
    schema: z__namespace.object({
        /**
     * The current available MFA token.
     */ mfaToken: z__namespace.nullable(z__namespace.string()),
        /**
     * Milliseconds since epoch of session expiration.
     */ sessionExpiration: z__namespace.number(),
        /**
     * Token will be undefined in environments with cookie based sessions.
     */ token: z__namespace.nullable(z__namespace.string())
    })
});

const hydrateStateWithStorage = async (client)=>{
    const core = getWalletProviderFromWalletAccount.getCore(client);
    const stateChanges = {};
    // ================ TOKEN =================
    const session = await core.storage.getItem(sessionKeySchema);
    const isSessionValid = (session == null ? void 0 : session.sessionExpiration) && session.sessionExpiration > Date.now();
    if (isSessionValid) {
        stateChanges.token = session.token;
        stateChanges.sessionExpiresAt = new Date(session.sessionExpiration);
        stateChanges.mfaToken = session.mfaToken;
    }
    // ================ STATE =================
    const storedState = await core.storage.getItem(stateStorageKeySchema);
    // Only hydrate state if it came from an API with the same version as the current SDK
    if ((storedState == null ? void 0 : storedState.apiVersion) === SDK_API_CORE_VERSION) {
        // Variables that should only be hydrated if the session is valid
        if (isSessionValid) {
            stateChanges.user = storedState.user;
            stateChanges.projectSettings = storedState.projectSettings;
        }
    }
    if (Object.keys(stateChanges).length > 0) {
        core.state.set(stateChanges);
    }
};

const syncStateWithStorage = (client)=>{
    const core = getWalletProviderFromWalletAccount.getCore(client);
    core.state.subscribe((state)=>{
        if (state.sessionExpiresAt === null) {
            void core.storage.removeItem(sessionKeySchema);
        } else {
            void core.storage.setItem(sessionKeySchema, {
                mfaToken: state.mfaToken,
                sessionExpiration: state.sessionExpiresAt.getTime(),
                token: state.token
            });
        }
        void core.storage.setItem(stateStorageKeySchema, {
            apiVersion: SDK_API_CORE_VERSION,
            projectSettings: state.projectSettings,
            user: state.user
        });
    });
};

const initializeStorageSync = async (client)=>{
    // Initialize the state value with what's stored in the storage
    await hydrateStateWithStorage(client);
    // Keep the storage up to date with the state
    syncStateWithStorage(client);
};

class ClientAlreadyInitializedError extends getWalletProviderFromWalletAccount.BaseError {
    constructor(){
        super({
            cause: null,
            code: 'client_already_initialized_error',
            docsUrl: null,
            name: 'ClientAlreadyInitializedError',
            shortMessage: 'Client must not be initialized more than once'
        });
    }
}

/**
 * Orchestrates the initialization of all modules and services of the SDK, and keeps
 * the loading flag updated.
 */ const initializeClient = async (client)=>{
    const core = getWalletProviderFromWalletAccount.getCore(client);
    if (core.state.get().initStatus !== 'uninitialized') {
        throw new ClientAlreadyInitializedError();
    }
    core.state.set({
        initStatus: 'in-progress'
    });
    initializeAuth(client);
    raiseStateEvents(client);
    const initializeStorageSyncPromise = initializeStorageSync(client);
    const fetchProjectSettingsPromise = initializeStorageSyncPromise.then(async ()=>{
        if (!core.state.get().projectSettings) {
            await fetchProjectSettings(client);
        }
    });
    core.initTrack.track({
        name: 'initialize-storage-sync',
        promise: initializeStorageSyncPromise
    });
    core.initTrack.track({
        name: 'fetch-project-settings',
        promise: fetchProjectSettingsPromise
    });
    try {
        await core.initTrack.waitForAll();
        core.state.set({
            initStatus: 'finished'
        });
    } catch (error) {
        core.state.set({
            initStatus: 'failed'
        });
        throw error;
    }
};

/**
 * Indicates if the code is running in a server-side environment.
 */ // eslint-disable-next-line no-restricted-globals
const isServerSideRendering = ()=>typeof window === 'undefined';

const createDeferredPromise = ()=>{
    let resolve;
    let reject;
    const promise = new Promise((_resolve, _reject)=>{
        resolve = _resolve;
        reject = _reject;
    });
    return {
        promise,
        reject: (reason)=>reject == null ? void 0 : reject(reason),
        resolve: (value)=>resolve == null ? void 0 : resolve(value)
    };
};

/**
 * Creates a tracker that associates names with promises and raises as promises resolve.
 */ const createAsyncTrack = ()=>{
    /**
   * Whether tracking is enabled.
   * All processes must be tracked on the same node tick.
   *
   * This ensures no process is missed (as it would throw when tracked on a different node tick).
   */ let isTrackEnabled = true;
    const eventEmitter = new EventEmitter.EventEmitter();
    const allSettledPromise = createDeferredPromise();
    const tracker = new Map();
    /**
   * Checks if all processes are initialized and resolves the main promise if they are.
   */ const checkIfAllSettled = ()=>{
        const allSettled = Array.from(tracker.values()).every((status)=>status === 'resolved');
        if (!allSettled) return;
        allSettledPromise.resolve();
    };
    const track = ({ name, promise })=>{
        if (!isTrackEnabled) {
            throw new getWalletProviderFromWalletAccount.CannotTrackError();
        }
        // Disable tracking in the next node tick
        void Promise.resolve().then(()=>isTrackEnabled = false);
        tracker.set(name, 'pending');
        promise.then(()=>{
            tracker.set(name, 'resolved');
            eventEmitter.emit('resolved', name);
            checkIfAllSettled();
        }).catch((error)=>{
            tracker.set(name, 'failed');
            eventEmitter.emit('failed', name, error);
            allSettledPromise.reject(error);
        });
    };
    const waitForAll = ()=>allSettledPromise.promise;
    const getTracker = ()=>tracker;
    return {
        getTracker,
        off: eventEmitter.off.bind(eventEmitter),
        on: eventEmitter.on.bind(eventEmitter),
        track,
        waitForAll
    };
};

const createEventEmitter = ()=>new EventEmitter();

class UnavailableInServerSideError extends getWalletProviderFromWalletAccount.BaseError {
    constructor(unavailableFeature){
        super({
            cause: null,
            code: 'unavailable_in_server_side_error',
            docsUrl: null,
            name: 'UnavailableInServerSideError',
            shortMessage: `This function is not available in server-side rendering: ${unavailableFeature}`
        });
    }
}

/**
 * Creates a fetch instance that uses the native window.fetch API.
 */ const createWebFetch = ()=>{
    if (isServerSideRendering()) {
        return ()=>Promise.reject(new UnavailableInServerSideError('createWebFetch'));
    }
    // eslint-disable-next-line no-restricted-globals -- this is the abstraction for fetch
    return window.fetch;
};

/**
 * Log levels and their corresponding numeric values
 */ const LOG_LEVELS = {
    debug: 0,
    error: 3,
    info: 1,
    warn: 2
};
// Assign to avoid lint errors
const defaultConsole = console;
/**
 * Creates a logger instance with configurable log level and event emission capabilities.
 * @returns A logger instance with debug, info, warn, and error methods
 */ const createLogger = (options = {})=>{
    const eventEmitter = new EventEmitter.EventEmitter();
    var _options_level;
    // Default to 'debug' if no level is provided
    const minLevel = (_options_level = options.level) != null ? _options_level : 'warn';
    // Helper to decide if we should log based on current log level
    const shouldLog = (level)=>{
        return LOG_LEVELS[level] >= LOG_LEVELS[minLevel];
    };
    // Helper to format the log message
    const formatMessage = (level, message)=>{
        const timestamp = new Date().toISOString();
        return `[${timestamp}] ${level.toUpperCase()}: ${message}`;
    };
    // Unified logger function that checks the level and calls the appropriate console method
    const log = (level, consoleMethod, message, ...args)=>{
        eventEmitter.emit('log', level, message, ...args);
        if (!shouldLog(level)) return;
        consoleMethod(formatMessage(level, message), ...args);
    };
    return {
        debug: (message, ...args)=>log('debug', defaultConsole.debug, message, ...args),
        error: (message, ...args)=>log('error', defaultConsole.error, message, ...args),
        info: (message, ...args)=>log('info', defaultConsole.info, message, ...args),
        off: eventEmitter.off.bind(eventEmitter),
        on: eventEmitter.on.bind(eventEmitter),
        warn: (message, ...args)=>log('warn', defaultConsole.warn, message, ...args)
    };
};

/**
 * Creates a navigation handler that uses the native window.location API.
 */ const createNavigationHandler = ()=>{
    if (isServerSideRendering()) {
        return ()=>Promise.reject(new UnavailableInServerSideError('createNavigationHandler'));
    }
    return async (url)=>{
        // eslint-disable-next-line no-restricted-globals -- this is the abstraction for navigation
        window.location.href = url;
    };
};

/**
 * Creates a deeplink opener that uses the native window.open API.
 */ const createWebDeeplinkOpener = ()=>{
    if (isServerSideRendering()) {
        return ()=>Promise.reject(new UnavailableInServerSideError('createWebDeeplinkOpener'));
    }
    return async (url)=>{
        // eslint-disable-next-line no-restricted-globals -- this is the abstraction for opening a deeplink
        window.open(url, '_blank');
    };
};

/**
 * Create a passkey service that uses the browser's WebAuthn API.
 */ const createWebPasskeyService = ()=>({
        authenticate: (options)=>browser.startAuthentication(options),
        isSupported: ()=>browser.browserSupportsWebAuthn(),
        register: (options)=>browser.startRegistration(options)
    });

/**
 * Creates a new runtime services instance that manages service registration and retrieval.
 *
 * @returns A RuntimeServices object with methods to get, register, and unregister services
 */ const createRuntimeServices = ()=>{
    const registry = new Map();
    return {
        getByKey: (key)=>registry.get(key),
        register: (key, service)=>registry.set(key, service),
        unregister: (key)=>registry.delete(key)
    };
};

class InvalidStorageValue extends getWalletProviderFromWalletAccount.BaseError {
    constructor(key, value){
        super({
            cause: null,
            code: 'invalid_storage_value',
            docsUrl: null,
            name: 'InvalidStorageValue',
            shortMessage: `Tried to store state with a forbidden value. Key: ${key}, Value: ${value}`
        });
    }
}

/**
 * Creates an observable state object that allows subscribing to immutable state changes.
 *
 * This function creates a state management system with the following capabilities:
 * - Get the current state
 * - Update state partially
 * - Subscribe to state changes
 * - Unsubscribe from state changes
 *
 * @param getInitialState - A function that returns the initial state object
 * @returns An ObservableState object with methods to manage and observe state changes
 * @example
 * ```typescript
 * const state = createObservableState(() => ({
 *   count: 0,
 *   name: 'John'
 * }));
 *
 * // Subscribe to changes
 * const unsubscribe = state.subscribe((current, previous) => {
 *   console.log('State changed:', current, 'Previous:', previous);
 * });
 *
 * // Update state
 * state.set({ count: 1 });
 *
 * // Get current state
 * const currentState = state.get();
 *
 * // Unsubscribe when done
 * unsubscribe();
 * ```
 */ const createObservableState = (getInitialState)=>{
    // ===============
    // NOTIFICATIONS
    // ===============
    const subscribers = new Set();
    const notifySubscribers = (value, previous)=>{
        subscribers.forEach((callback)=>callback(value, previous));
    };
    const subscribe = (callback)=>{
        subscribers.add(callback);
        return ()=>unsubscribe(callback);
    };
    const unsubscribe = (callback)=>{
        subscribers.delete(callback);
    };
    // ===============
    // STATE
    // ===============
    let currentState = getInitialState();
    const get = ()=>currentState;
    const set = (partial)=>{
        const previous = currentState;
        Object.entries(partial).forEach(([key, value])=>{
            if (value === undefined) {
                throw new InvalidStorageValue(key, value);
            }
        });
        currentState = Object.assign({}, currentState, partial);
        notifySubscribers(currentState, previous);
    };
    return {
        get,
        getInitialState,
        set,
        subscribe,
        unsubscribe
    };
};

/**
 * The default API base URL for Dynamic apps in production.
 */ const DEFAULT_API_BASE_URL = 'https://app.dynamic.xyz/api/v0';

/**
 * The initial values for the state of the client.
 */ const getInitialState = ()=>({
        initStatus: 'uninitialized',
        mfaToken: null,
        projectSettings: null,
        sessionExpiresAt: null,
        token: null,
        unverifiedWalletAccounts: [],
        user: null
    });

/**
 * Creates a core instance that contains all the services and state of the Dynamic SDK client.
 */ const createCore = (config)=>{
    var _config_coreConfig, _config_coreConfig1, _config_coreConfig2, _config_coreConfig3, _config_coreConfig4, _config_coreConfig5, _config_coreConfig6, _config_coreConfig7;
    var _config_coreConfig_apiBaseUrl;
    const apiBaseUrl = (_config_coreConfig_apiBaseUrl = (_config_coreConfig = config.coreConfig) == null ? void 0 : _config_coreConfig.apiBaseUrl) != null ? _config_coreConfig_apiBaseUrl : DEFAULT_API_BASE_URL;
    var _config_coreConfig_logger;
    const logger = (_config_coreConfig_logger = (_config_coreConfig1 = config.coreConfig) == null ? void 0 : _config_coreConfig1.logger) != null ? _config_coreConfig_logger : createLogger();
    var _config_coreConfig_storage;
    const storage = (_config_coreConfig_storage = (_config_coreConfig2 = config.coreConfig) == null ? void 0 : _config_coreConfig2.storage) != null ? _config_coreConfig_storage : createWebStorage({
        prefix: `dynamic_${config.environmentId}`
    });
    var _config_coreConfig_fetch;
    const fetch = (_config_coreConfig_fetch = (_config_coreConfig3 = config.coreConfig) == null ? void 0 : _config_coreConfig3.fetch) != null ? _config_coreConfig_fetch : createWebFetch();
    var _config_coreConfig_openDeeplink;
    const openDeeplink = (_config_coreConfig_openDeeplink = (_config_coreConfig4 = config.coreConfig) == null ? void 0 : _config_coreConfig4.openDeeplink) != null ? _config_coreConfig_openDeeplink : createWebDeeplinkOpener();
    var _config_coreConfig_navigate;
    const navigate = (_config_coreConfig_navigate = (_config_coreConfig5 = config.coreConfig) == null ? void 0 : _config_coreConfig5.navigate) != null ? _config_coreConfig_navigate : createNavigationHandler();
    const state = createObservableState(getInitialState);
    const eventEmitter = createEventEmitter();
    const initTrack = createAsyncTrack();
    const runtimeServices = createRuntimeServices();
    var _config_coreConfig_passkey;
    const passkey = (_config_coreConfig_passkey = (_config_coreConfig6 = config.coreConfig) == null ? void 0 : _config_coreConfig6.passkey) != null ? _config_coreConfig_passkey : createWebPasskeyService();
    var _config_coreConfig_getApiHeaders;
    return {
        apiBaseUrl,
        environmentId: config.environmentId,
        eventEmitter,
        extensions: new Set(),
        fetch,
        getApiHeaders: (_config_coreConfig_getApiHeaders = (_config_coreConfig7 = config.coreConfig) == null ? void 0 : _config_coreConfig7.getApiHeaders) != null ? _config_coreConfig_getApiHeaders : ()=>({}),
        initTrack,
        logger,
        metadata: config.metadata,
        navigate,
        openDeeplink,
        passkey,
        runtimeServices,
        state,
        storage,
        version: getWalletProviderFromWalletAccount.version
    };
};

/**
 * Creates a new DynamicClient instance.
 *
 * Notice the `autoInitialize` flag is true by default (unless you're running
 * in SSR), so the client will be automatically initialized when created — if
 * you want to manually initialize the client, you can set the `autoInitialize`
 * flag to false and then later call the `initializeClient` function.
 *
 * Manually calling `initializeClient` also allows you to catch any potential
 * errors that may occur during initialization.
 */ const createDynamicClient = (config)=>{
    const core = createCore(config);
    const client = {
        get __core () {
            return core;
        },
        get initStatus () {
            return core.state.get().initStatus;
        },
        get mfaToken () {
            return core.state.get().mfaToken;
        },
        get projectSettings () {
            return core.state.get().projectSettings;
        },
        get token () {
            return core.state.get().token;
        },
        get user () {
            return core.state.get().user;
        }
    };
    var _config_autoInitialize;
    const shouldAutoInitialize = (_config_autoInitialize = config.autoInitialize) != null ? _config_autoInitialize : !isServerSideRendering();
    if (shouldAutoInitialize) {
        void initializeClient(client);
    }
    return client;
};

class InvalidRedirectStorageStateError extends getWalletProviderFromWalletAccount.BaseError {
    constructor(){
        super({
            cause: null,
            code: 'invalid_redirect_storage_state_error',
            docsUrl: null,
            name: 'InvalidRedirectStorageStateError',
            shortMessage: 'The social redirect data found in local storage does not match the expected state. Try connecting again.'
        });
    }
}

class MissingRedirectStorageStateError extends getWalletProviderFromWalletAccount.BaseError {
    constructor(){
        super({
            cause: null,
            code: 'missing_redirect_storage_state_error',
            docsUrl: null,
            name: 'MissingRedirectStorageStateError',
            shortMessage: 'The social redirect data was not found in local storage. Try connecting again.'
        });
    }
}

class MissingSocialUrlParamError extends getWalletProviderFromWalletAccount.BaseError {
    constructor(param){
        super({
            cause: null,
            code: 'missing_social_url_param_error',
            docsUrl: null,
            name: 'MissingSocialParamError',
            shortMessage: `To complete social sign in, the following URL query parameter is required to be set but was not found: ${param}`
        });
    }
}

class NoAddressFoundError extends getWalletProviderFromWalletAccount.BaseError {
    constructor(){
        super({
            cause: null,
            code: 'no_address_found_error',
            docsUrl: null,
            name: 'NoAddressFoundError',
            shortMessage: 'No address is connected to the wallet'
        });
    }
}

class NoPasskeyCredentialsFoundError extends getWalletProviderFromWalletAccount.BaseError {
    constructor(){
        super({
            cause: null,
            code: 'no_passkey_credentials_found_error',
            docsUrl: null,
            name: 'NoPasskeyCredentialsFoundError',
            shortMessage: 'No passkey credentials found'
        });
    }
}

class NoWebAuthNSupportError extends getWalletProviderFromWalletAccount.BaseError {
    constructor(){
        super({
            cause: null,
            code: 'no_webauthn_support_error',
            docsUrl: null,
            name: 'NoWebAuthNSupportError',
            shortMessage: 'Browser does not support WebAuthn'
        });
    }
}

class UserNotAuthenticatedError extends getWalletProviderFromWalletAccount.BaseError {
    constructor({ shortMessage } = {}){
        super({
            cause: null,
            code: 'user_not_authenticated_error',
            docsUrl: null,
            name: 'UserNotAuthenticatedError',
            shortMessage: shortMessage != null ? shortMessage : 'User not authenticated'
        });
    }
}

class WalletAccountAlreadyVerifiedError extends getWalletProviderFromWalletAccount.BaseError {
    constructor(address){
        super({
            cause: null,
            code: 'wallet_account_already_verified_error',
            docsUrl: null,
            name: 'WalletAccountAlreadyVerifiedError',
            shortMessage: `Wallet account ${address} is already verified`
        });
    }
}

class WalletAccountNotSelectedError extends getWalletProviderFromWalletAccount.BaseError {
    constructor(params){
        super({
            cause: null,
            code: 'wallet_account_not_selected_error',
            docsUrl: null,
            name: 'WalletAccountNotSelected',
            shortMessage: `This wallet only supports signing with its selected account (currently ${params.selectedAddress}). Please select account ${params.expectedAddress} in your wallet app and try again`
        });
        this.expectedAddress = params.expectedAddress;
        this.selectedAddress = params.selectedAddress;
    }
}

class WalletAlreadyLinkedToAnotherUserError extends getWalletProviderFromWalletAccount.BaseError {
    constructor({ cause }){
        super({
            cause,
            code: 'wallet_already_linked_to_another_user_error',
            docsUrl: null,
            name: 'WalletAlreadyLinkedToAnotherUserError',
            shortMessage: 'This wallet is already linked to another user'
        });
    }
}

const getPasskeyAuthenticationOptions = async (client)=>{
    const core = getWalletProviderFromWalletAccount.getCore(client);
    const apiClient = getWalletProviderFromWalletAccount.createApiClient(client);
    const options = await apiClient.getPasskeyAuthenticationOptions({
        environmentId: core.environmentId
    });
    return options;
};

const getPasskeys = async (client)=>{
    const core = getWalletProviderFromWalletAccount.getCore(client);
    const apiClient = getWalletProviderFromWalletAccount.createApiClient(client);
    const response = await apiClient.getUserPasskeys({
        environmentId: core.environmentId
    });
    return response.passkeys;
};

const updateAuthFromVerifyResponse = (client, response)=>{
    const core = getWalletProviderFromWalletAccount.getCore(client);
    const { user, minifiedJwt, expiresAt, mfaToken } = response;
    core.state.set({
        mfaToken: mfaToken != null ? mfaToken : null,
        // Expires at is in seconds, so we need to convert it to milliseconds
        sessionExpiresAt: new Date(expiresAt * 1000),
        token: minifiedJwt != null ? minifiedJwt : null,
        user
    });
    core.eventEmitter.emit('authenticated', {
        verifyResponse: response
    });
};

const getPasskeyRegistrationOptions = async (client)=>{
    const core = getWalletProviderFromWalletAccount.getCore(client);
    const apiClient = getWalletProviderFromWalletAccount.createApiClient(client);
    const options = await apiClient.getPasskeyRegistrationOptions({
        environmentId: core.environmentId
    });
    return options;
};

const serverRegisterPasskey = async (client, registration)=>{
    const core = getWalletProviderFromWalletAccount.getCore(client);
    const apiClient = getWalletProviderFromWalletAccount.createApiClient(client);
    const response = await apiClient.registerPasskey({
        environmentId: core.environmentId,
        passkeyRegisterRequest: getWalletProviderFromWalletAccount._extends({}, registration, {
            response: getWalletProviderFromWalletAccount._extends({}, registration.response, {
                clientDataJson: registration.response.clientDataJSON
            })
        })
    });
    return response;
};

const registerPasskey = async (client)=>{
    const core = getWalletProviderFromWalletAccount.getCore(client);
    if (!core.passkey.isSupported()) {
        throw new NoWebAuthNSupportError();
    }
    const options = await getPasskeyRegistrationOptions(client);
    const registration = await core.passkey.register({
        optionsJSON: options
    });
    const response = await serverRegisterPasskey(client, registration);
    updateAuthFromVerifyResponse(client, response);
    return response;
};

const getPasskeyAuthenticationSignInOptions = async (client)=>{
    const core = getWalletProviderFromWalletAccount.getCore(client);
    const apiClient = getWalletProviderFromWalletAccount.createApiClient(client);
    const options = await apiClient.getPasskeyAuthenticationSigninOptions({
        environmentId: core.environmentId
    });
    return options;
};

const serverSigninPasskey = async (client, authentication, createMfaToken)=>{
    const core = getWalletProviderFromWalletAccount.getCore(client);
    const apiClient = getWalletProviderFromWalletAccount.createApiClient(client);
    const response = await apiClient.signinWithPasskey({
        environmentId: core.environmentId,
        passkeyAuthRequest: getWalletProviderFromWalletAccount._extends({}, authentication, {
            createMfaToken,
            response: getWalletProviderFromWalletAccount._extends({}, authentication.response, {
                clientDataJson: authentication.response.clientDataJSON
            })
        })
    });
    return response;
};

const signInWithPasskey = async (client)=>{
    const core = getWalletProviderFromWalletAccount.getCore(client);
    if (!core.passkey.isSupported()) {
        throw new NoWebAuthNSupportError();
    }
    const options = await getPasskeyAuthenticationSignInOptions(client);
    const formattedOptions = getWalletProviderFromWalletAccount._extends({}, options);
    const authentication = await core.passkey.authenticate({
        optionsJSON: formattedOptions
    });
    const response = await serverSigninPasskey(client, authentication);
    updateAuthFromVerifyResponse(client, response);
    return response;
};

/** The schema to track the state of the OAuth flow. */ const redirectStateStorageSchema = createStorageKeySchema({
    key: 'redirectState',
    schema: z__namespace.object({
        captchaToken: z__namespace.optional(z__namespace.string()),
        codeVerifier: z__namespace.optional(z__namespace.string()),
        provider: z__namespace.enum(sdkApiCore.ProviderEnum),
        state: z__namespace.string()
    })
});

/** Completes the social redirect sign in flow. */ const completeSocialRedirectSignIn = async (/** The DynamicClient instance. */ client, /** The parameters for the complete social redirect sign in. */ { url })=>{
    const core = getWalletProviderFromWalletAccount.getCore(client);
    const apiClient = getWalletProviderFromWalletAccount.createApiClient(client);
    await core.initTrack.waitForAll();
    const dynamicOauthState = url.searchParams.get('dynamicOauthState');
    const dynamicOauthCode = url.searchParams.get('dynamicOauthCode');
    if (!dynamicOauthState) {
        throw new MissingSocialUrlParamError('dynamicOauthState');
    }
    if (!dynamicOauthCode) {
        throw new MissingSocialUrlParamError('dynamicOauthCode');
    }
    const storedSocialRedirectState = await core.storage.getItem(redirectStateStorageSchema);
    if (!storedSocialRedirectState) {
        throw new MissingRedirectStorageStateError();
    }
    if (storedSocialRedirectState.state !== dynamicOauthState) {
        throw new InvalidRedirectStorageStateError();
    }
    const { provider, codeVerifier, captchaToken } = storedSocialRedirectState;
    await core.storage.removeItem(redirectStateStorageSchema);
    const response = await apiClient.oauthSignIn({
        environmentId: core.environmentId,
        oauthRequest: {
            captchaToken,
            code: dynamicOauthCode,
            codeVerifier,
            state: dynamicOauthState
        },
        providerType: provider
    });
    updateAuthFromVerifyResponse(client, response);
    return response.user;
};

/** Detects if the URL is a redirect from an OAuth provider. */ const detectOAuthRedirect = async (/** The DynamicClient instance. */ client, /** The options for the detect OAuth redirect. */ { url })=>{
    const core = getWalletProviderFromWalletAccount.getCore(client);
    const dynamicOauthState = url.searchParams.get('dynamicOauthState');
    const dynamicOauthCode = url.searchParams.get('dynamicOauthCode');
    if (!dynamicOauthState || !dynamicOauthCode) {
        return false;
    }
    // Wait for SDK to load
    await core.initTrack.waitForAll();
    const storedSocialRedirectState = await core.storage.getItem(redirectStateStorageSchema);
    if (!storedSocialRedirectState || storedSocialRedirectState.state !== dynamicOauthState) {
        return false;
    }
    return true;
};

const digestSHA256 = (str)=>{
    const encoder = new TextEncoder();
    const data = encoder.encode(str);
    return crypto.subtle.digest('SHA-256', data);
};

/**
 * Encodes a string to base64url.
 *
 * @param str - The string to encode as an ArrayBuffer.
 * @returns The base64url encoded string.
 */ const encodeBase64Url = (str)=>{
    const numberArray = [];
    new Uint8Array(str).forEach((item)=>numberArray.push(item));
    // Deprecated btoa used for web compatibility
    return btoa(String.fromCharCode.apply(null, numberArray)).replace(/=/g, '').replace(/\+/g, '-').replace(/\//g, '_');
};

const APPLE_RESPONSE_MODE = 'form_post';
const APPLE_RESPONSE_TYPE = 'code id_token';
/** Helper function to add OAuth URL parameters to a given base URL. */ const addOAuthUrlParams = (provider, baseUrl)=>{
    getWalletProviderFromWalletAccount.assertDefined(provider.clientId, 'Client ID not found');
    getWalletProviderFromWalletAccount.assertDefined(provider.provider, 'Provider type not found');
    getWalletProviderFromWalletAccount.assertDefined(provider.redirectUrl, 'Redirect URL not found');
    const providerType = provider.provider;
    baseUrl.searchParams.set('client_id', provider.clientId);
    baseUrl.searchParams.set('response_type', 'code');
    baseUrl.searchParams.set('redirect_uri', provider.redirectUrl);
    if (providerType === sdkApiCore.ProviderEnum.Tiktok) {
        baseUrl.searchParams.delete('client_id');
        baseUrl.searchParams.set('client_key', provider.clientId);
    }
    if (providerType === sdkApiCore.ProviderEnum.Google) {
        baseUrl.searchParams.set('access_type', 'offline');
    }
    // Add logic for providers that require additional parameters
    if (providerType === sdkApiCore.ProviderEnum.Apple) {
        baseUrl.searchParams.set('response_mode', APPLE_RESPONSE_MODE);
        baseUrl.searchParams.set('response_type', APPLE_RESPONSE_TYPE);
    }
    if (provider.scopes) {
        baseUrl.searchParams.set('scope', provider.scopes);
    }
    return baseUrl;
};

/** Helper function to build the OAuth base URL for a given provider. */ const getOAuthBaseUrl = (provider)=>{
    getWalletProviderFromWalletAccount.assertDefined(provider.provider, 'Provider type not found');
    const providerType = provider.provider;
    if (providerType === sdkApiCore.ProviderEnum.Telegram) {
        getWalletProviderFromWalletAccount.assertDefined(provider.authorizationUrl, 'Telegram authorization URL not found');
        return new URL(provider.authorizationUrl);
    }
    getWalletProviderFromWalletAccount.assertDefined(provider.baseAuthUrl, 'Base auth URL not found');
    if (providerType === sdkApiCore.ProviderEnum.Shopify) {
        getWalletProviderFromWalletAccount.assertDefined(provider.shopifyStore, 'Shopify store value not found in provider');
        const loginBaseUrl = provider.baseAuthUrl.replace('{{shopifyStore}}', provider.shopifyStore);
        return new URL(loginBaseUrl);
    }
    return new URL(provider.baseAuthUrl);
};

const providersRequiringPkce = [
    'twitter',
    'github'
];
/** Helper function to build the OAuth URL for a given provider. */ const buildOAuthUrl = async (/** The core instance. */ core, /** The provider to build the OAuth URL for. */ provider)=>{
    const { projectSettings } = core.state.get();
    // Check if the provider is supported
    getWalletProviderFromWalletAccount.assertDefined(projectSettings, 'Project settings not found');
    getWalletProviderFromWalletAccount.assertDefined(projectSettings.providers, 'Project providers not found');
    const socialProvider = projectSettings.providers.find((p)=>p.provider === provider);
    getWalletProviderFromWalletAccount.assertDefined(socialProvider, `Social provider ${provider} not supported`);
    // Build the OAuth URL
    const loginBaseUrl = getOAuthBaseUrl(socialProvider);
    const socialProviderUrl = addOAuthUrlParams(socialProvider, loginBaseUrl);
    // Add PKCE and state parameters
    const usingPkce = providersRequiringPkce.includes(provider);
    const state = getWalletProviderFromWalletAccount.randomString(32);
    const codeVerifier = getWalletProviderFromWalletAccount.randomString(43);
    socialProviderUrl.searchParams.set('state', state);
    socialProviderUrl.searchParams.set('response_type', 'code');
    if (usingPkce) {
        const digest = await digestSHA256(codeVerifier);
        socialProviderUrl.searchParams.set('code_challenge', encodeBase64Url(digest));
        socialProviderUrl.searchParams.set('code_challenge_method', 'S256');
    }
    return {
        codeVerifier: usingPkce ? codeVerifier : undefined,
        state,
        url: socialProviderUrl
    };
};

/** Redirects the user to the OAuth provider's authorization page */ const signInWithSocialRedirect = async (/** The DynamicClient instance. */ client, /** The options for the sign in with social redirect. */ { provider, redirectUrl, captchaToken })=>{
    const core = getWalletProviderFromWalletAccount.getCore(client);
    await core.initTrack.waitForAll();
    const providerType = provider;
    const { url, state, codeVerifier } = await buildOAuthUrl(core, providerType);
    await getWalletProviderFromWalletAccount.createApiClient(client).initAuth({
        environmentId: core.environmentId,
        oauthInitAuthRequest: {
            redirectUrl,
            state
        },
        providerType
    });
    await core.storage.setItem(redirectStateStorageSchema, {
        captchaToken,
        codeVerifier,
        provider: providerType,
        state
    });
    await core.navigate(url.toString());
};

const getMultichainBalances = async (client, balanceRequest)=>{
    const core = getWalletProviderFromWalletAccount.getCore(client);
    const apiClient = getWalletProviderFromWalletAccount.createApiClient(client);
    const response = await apiClient.postMultichainAccountBalances({
        environmentId: core.environmentId,
        multichainAccountBalancesRequest: balanceRequest
    });
    return response.chainBalances;
};

const updateUser = async (client, userFields)=>{
    const core = getWalletProviderFromWalletAccount.getCore(client);
    const apiClient = getWalletProviderFromWalletAccount.createApiClient(client, {
        includeMfaToken: true
    });
    const response = await apiClient.updateSelf({
        environmentId: core.environmentId,
        userFields
    });
    updateAuthFromVerifyResponse(client, response);
    if (response.emailVerification) {
        return getWalletProviderFromWalletAccount.assignClient({
            email: response.emailVerification.email,
            verificationUUID: response.emailVerification.verificationUUID
        }, client);
    }
    if (response.smsVerification) {
        return getWalletProviderFromWalletAccount.assignClient({
            isoCountryCode: response.smsVerification.isoCountryCode,
            phoneCountryCode: response.smsVerification.phoneCountryCode,
            phoneNumber: response.smsVerification.phoneNumber,
            verificationUUID: response.smsVerification.verificationUUID
        }, client);
    }
    return undefined;
};

const acknowledgeRecoveryCodes = async (client)=>{
    return updateUser(client, {
        mfaBackupCodeAcknowledgement: sdkApiCore.MfaBackupCodeAcknowledgement.Complete
    });
};

const serverAuthenticatePasskey = async (client, authentication, createMfaToken)=>{
    const core = getWalletProviderFromWalletAccount.getCore(client);
    const apiClient = getWalletProviderFromWalletAccount.createApiClient(client);
    const response = await apiClient.authenticateMfaPasskeyDevice({
        environmentId: core.environmentId,
        passkeyAuthRequest: getWalletProviderFromWalletAccount._extends({}, authentication, {
            createMfaToken,
            response: getWalletProviderFromWalletAccount._extends({}, authentication.response, {
                clientDataJson: authentication.response.clientDataJSON
            })
        })
    });
    return response;
};

const authenticatePasskeyMFA = async (client, { createMfaToken } = {})=>{
    const core = getWalletProviderFromWalletAccount.getCore(client);
    try {
        var _options_allowCredentials;
        if (!core.passkey.isSupported()) {
            throw new NoWebAuthNSupportError();
        }
        const options = await getPasskeyAuthenticationOptions(client);
        const allowCredentials = (_options_allowCredentials = options.allowCredentials) == null ? void 0 : _options_allowCredentials.map((credential)=>getWalletProviderFromWalletAccount._extends({}, credential, {
                type: 'public-key'
            }));
        if (!(allowCredentials == null ? void 0 : allowCredentials.length)) {
            throw new NoPasskeyCredentialsFoundError();
        }
        // Ensure allowCredentials has the required type property
        const formattedOptions = getWalletProviderFromWalletAccount._extends({}, options, {
            allowCredentials
        });
        const authentication = await core.passkey.authenticate({
            optionsJSON: formattedOptions
        });
        const response = await serverAuthenticatePasskey(client, authentication, createMfaToken);
        updateAuthFromVerifyResponse(client, response);
        getWalletProviderFromWalletAccount.emitEvent(client, 'mfaCompletionSuccess', {
            mfaToken: response.mfaToken
        });
        return response;
    } catch (error) {
        getWalletProviderFromWalletAccount.emitEvent(client, 'mfaCompletionFailure', {
            error
        });
        throw error;
    }
};

/**
 * Authenticates and return the MFA token with a recovery code.
 */ const authMfaRecoveryCode = async (client, { code })=>{
    const core = getWalletProviderFromWalletAccount.getCore(client);
    const apiClient = getWalletProviderFromWalletAccount.createApiClient(client);
    try {
        const response = await apiClient.authMfaRecovery({
            environmentId: core.environmentId,
            mFAAuthRecoveryDevicePostRequest: {
                code
            }
        });
        updateAuthFromVerifyResponse(client, response);
        getWalletProviderFromWalletAccount.emitEvent(client, 'mfaCompletionSuccess', {
            mfaToken: response.mfaToken
        });
        return response;
    } catch (error) {
        getWalletProviderFromWalletAccount.emitEvent(client, 'mfaCompletionFailure', {
            error
        });
        throw error;
    }
};

/**
 * Authenticates and return the MFA token for a TOTP device.
 */ const authTotpMfaDevice = async (client, { deviceId, code, createMfaTokenOptions })=>{
    const core = getWalletProviderFromWalletAccount.getCore(client);
    const apiClient = getWalletProviderFromWalletAccount.createApiClient(client);
    try {
        const response = await apiClient.authMfaTotpDevice({
            environmentId: core.environmentId,
            mFAAuthTotpDevicePostRequest: {
                code,
                createMfaToken: createMfaTokenOptions,
                id: deviceId
            }
        });
        updateAuthFromVerifyResponse(client, response);
        getWalletProviderFromWalletAccount.emitEvent(client, 'mfaCompletionSuccess', {
            deviceId,
            mfaToken: response.mfaToken
        });
        return response;
    } catch (error) {
        getWalletProviderFromWalletAccount.emitEvent(client, 'mfaCompletionFailure', {
            deviceId,
            error
        });
        throw error;
    }
};

const consumeMfaToken = (client)=>{
    const core = getWalletProviderFromWalletAccount.getCore(client);
    const mfaToken = core.state.get().mfaToken;
    getWalletProviderFromWalletAccount.assertDefined(mfaToken, 'No MFA token found');
    core.state.set({
        mfaToken: null
    });
    return mfaToken;
};

/**
 * Creates new MFA recovery codes for the user.
 */ const createNewMfaRecoveryCodes = async (client)=>{
    const core = getWalletProviderFromWalletAccount.getCore(client);
    const apiClient = getWalletProviderFromWalletAccount.createApiClient(client);
    return apiClient.createNewRecoveryCodes({
        environmentId: core.environmentId
    });
};

/**
 * Deletes a MFA device
 */ const deleteMfaDevice = async (device, { mfaAuthToken })=>{
    const client = getWalletProviderFromWalletAccount.getClient(device);
    const core = getWalletProviderFromWalletAccount.getCore(client);
    const apiClient = getWalletProviderFromWalletAccount.createApiClient(client);
    getWalletProviderFromWalletAccount.assertDefined(device.id, 'device.id is required');
    getWalletProviderFromWalletAccount.assertDefined(mfaAuthToken, 'mfaAuthToken is required');
    return apiClient.deleteMfaDevice({
        environmentId: core.environmentId,
        mfaDeviceId: device.id,
        xMfaAuthToken: mfaAuthToken
    });
};

const getMfaDevices = async (client)=>{
    const core = getWalletProviderFromWalletAccount.getCore(client);
    const apiClient = getWalletProviderFromWalletAccount.createApiClient(client);
    const { devices } = await apiClient.getUserMfaDevices({
        environmentId: core.environmentId
    });
    return devices.map((device)=>getWalletProviderFromWalletAccount.assignClient(device, client));
};

const getMfaMethods = async (client, { verifiedOnly = false } = {})=>{
    const core = getWalletProviderFromWalletAccount.getCore(client);
    const apiClient = getWalletProviderFromWalletAccount.createApiClient(client);
    const userMfaMethods = await apiClient.getUserMfaMethods({
        environmentId: core.environmentId,
        verifiedOnly
    });
    return getWalletProviderFromWalletAccount._extends({}, userMfaMethods, {
        devices: userMfaMethods.devices.map((device)=>getWalletProviderFromWalletAccount.assignClient(device, client)),
        passkeys: userMfaMethods.passkeys.map((passkey)=>getWalletProviderFromWalletAccount.assignClient(passkey, client))
    });
};

/**
 * Returns the recovery codes for the user's MFA device.
 */ const getMfaRecoveryCodes = async (client)=>{
    const core = getWalletProviderFromWalletAccount.getCore(client);
    const apiClient = getWalletProviderFromWalletAccount.createApiClient(client);
    return apiClient.getRecoveryCodes({
        environmentId: core.environmentId
    });
};

const isPendingRecoveryCodesAcknowledgment = (client)=>{
    const user = client.user;
    getWalletProviderFromWalletAccount.assertDefined(user, 'User not logged in');
    return user.mfaBackupCodeAcknowledgement !== sdkApiCore.MfaBackupCodeAcknowledgement.Complete;
};

const isUserMissingMfaAuth = (client)=>{
    var _user_scope;
    const user = client.user;
    getWalletProviderFromWalletAccount.assertDefined(user, 'User not logged in');
    return Boolean((_user_scope = user.scope) == null ? void 0 : _user_scope.includes('requiresAdditionalAuth'));
};

const registerTotpMfaDevice = async (client)=>{
    const core = getWalletProviderFromWalletAccount.getCore(client);
    const apiClient = getWalletProviderFromWalletAccount.createApiClient(client);
    return apiClient.registerTotpMfaDevice({
        environmentId: core.environmentId
    });
};

const setDefaultMfaDevice = async (device)=>{
    const client = getWalletProviderFromWalletAccount.getClient(device);
    const core = getWalletProviderFromWalletAccount.getCore(client);
    const apiClient = getWalletProviderFromWalletAccount.createApiClient(client);
    getWalletProviderFromWalletAccount.assertDefined(device.id, 'device.id is required');
    // All that this endpoint does is set the default device to the one provided.
    return apiClient.updateUserMfaDevice({
        environmentId: core.environmentId,
        mfaDeviceId: device.id
    });
};

const sendEmailOTP = async (client, { email })=>{
    const core = getWalletProviderFromWalletAccount.getCore(client);
    const apiClient = getWalletProviderFromWalletAccount.createApiClient(client);
    const { verificationUUID } = await apiClient.createEmailVerification({
        emailVerificationCreateRequest: {
            email
        },
        environmentId: core.environmentId
    });
    return getWalletProviderFromWalletAccount.assignClient({
        email,
        verificationUUID
    }, client);
};

// Source:
// https://github.com/dynamic-labs/redcoast/blob/main/apps/dashboard/src/app/routes/Configurations/Providers/components/SmsProviderSection/utils/countries.ts
// these are the countries was populated based on the wikipedia page
// referenced in twilio's docs: https://www.twilio.com/docs/voice/api/dialingpermissions-country-resource
// and this doc for country codes: https://www.itu.int/itudoc/itu-t/ob-lists/icc/e164_763.pdf
const supportedCountries = {
    AC: {
        code: '247',
        name: 'Ascension'
    },
    AD: {
        code: '376',
        name: 'Andorra'
    },
    AE: {
        code: '971',
        name: 'United Arab Emirates'
    },
    AF: {
        code: '93',
        name: 'Afghanistan'
    },
    AG: {
        code: '1268',
        name: 'Antigua and Barbuda'
    },
    AI: {
        code: '1264',
        name: 'Anguilla'
    },
    AL: {
        code: '355',
        name: 'Albania'
    },
    AM: {
        code: '374',
        name: 'Armenia'
    },
    AO: {
        code: '244',
        name: 'Angola'
    },
    AR: {
        code: '54',
        name: 'Argentina'
    },
    AS: {
        code: '1684',
        name: 'American Samoa'
    },
    AT: {
        code: '43',
        name: 'Austria'
    },
    AU: {
        code: '61',
        name: 'Australia/Cocos/Christmas Island'
    },
    AW: {
        code: '297',
        name: 'Aruba'
    },
    AZ: {
        code: '994',
        name: 'Azerbaijan'
    },
    BA: {
        code: '387',
        name: 'Bosnia and Herzegovina'
    },
    BB: {
        code: '1246',
        name: 'Barbados'
    },
    BD: {
        code: '880',
        name: 'Bangladesh'
    },
    BE: {
        code: '32',
        name: 'Belgium'
    },
    BF: {
        code: '226',
        name: 'Burkina Faso'
    },
    BG: {
        code: '359',
        name: 'Bulgaria'
    },
    BH: {
        code: '973',
        name: 'Bahrain'
    },
    BI: {
        code: '257',
        name: 'Burundi'
    },
    BJ: {
        code: '229',
        name: 'Benin'
    },
    BM: {
        code: '1441',
        name: 'Bermuda'
    },
    BN: {
        code: '673',
        name: 'Brunei'
    },
    BO: {
        code: '591',
        name: 'Bolivia'
    },
    BR: {
        code: '55',
        name: 'Brazil'
    },
    BS: {
        code: '1242',
        name: 'Bahamas'
    },
    BT: {
        code: '975',
        name: 'Bhutan'
    },
    BW: {
        code: '267',
        name: 'Botswana'
    },
    BY: {
        code: '375',
        name: 'Belarus'
    },
    BZ: {
        code: '501',
        name: 'Belize'
    },
    CA: {
        code: '1',
        name: 'Canada'
    },
    CD: {
        code: '243',
        name: 'Congo, Dem Rep'
    },
    CF: {
        code: '236',
        name: 'Central Africa'
    },
    CG: {
        code: '242',
        name: 'Congo'
    },
    CH: {
        code: '41',
        name: 'Switzerland'
    },
    CI: {
        code: '225',
        name: 'Ivory Coast'
    },
    CK: {
        code: '682',
        name: 'Cook Islands'
    },
    CL: {
        code: '56',
        name: 'Chile'
    },
    CM: {
        code: '237',
        name: 'Cameroon'
    },
    CN: {
        code: '86',
        name: 'China'
    },
    CO: {
        code: '57',
        name: 'Colombia'
    },
    CR: {
        code: '506',
        name: 'Costa Rica'
    },
    CU: {
        code: '53',
        name: 'Cuba'
    },
    CV: {
        code: '238',
        name: 'Cape Verde'
    },
    CW: {
        code: '599',
        name: 'Curaçao and Caribbean Netherlands (Bonaire, Sint Eustatius, Sint Maarten, Saba)'
    },
    CY: {
        code: '357',
        name: 'Cyprus'
    },
    CZ: {
        code: '420',
        name: 'Czech Republic'
    },
    DE: {
        code: '49',
        name: 'Germany'
    },
    DJ: {
        code: '253',
        name: 'Djibouti'
    },
    DK: {
        code: '45',
        name: 'Denmark'
    },
    DM: {
        code: '1767',
        name: 'Dominica'
    },
    DO: {
        code: '1829',
        name: 'Dominican Republic'
    },
    DZ: {
        code: '213',
        name: 'Algeria'
    },
    EC: {
        code: '593',
        name: 'Ecuador'
    },
    EE: {
        code: '372',
        name: 'Estonia'
    },
    EG: {
        code: '20',
        name: 'Egypt'
    },
    ER: {
        code: '291',
        name: 'Eritrea'
    },
    ES: {
        code: '34',
        name: 'Spain'
    },
    ET: {
        code: '251',
        name: 'Ethiopia'
    },
    FI: {
        code: '358',
        name: 'Finland/Aland Islands'
    },
    FJ: {
        code: '679',
        name: 'Fiji'
    },
    FK: {
        code: '500',
        name: 'Falkland Islands'
    },
    FM: {
        code: '691',
        name: 'Micronesia'
    },
    FO: {
        code: '298',
        name: 'Faroe Islands'
    },
    FR: {
        code: '33',
        name: 'France'
    },
    GA: {
        code: '241',
        name: 'Gabon'
    },
    GB: {
        code: '44',
        name: 'United Kingdom'
    },
    GD: {
        code: '1473',
        name: 'Grenada'
    },
    GE: {
        code: '995',
        name: 'Georgia'
    },
    GF: {
        code: '594',
        name: 'French Guiana'
    },
    GG: {
        code: '44',
        name: 'Guernsey/Jersey'
    },
    GH: {
        code: '233',
        name: 'Ghana'
    },
    GI: {
        code: '350',
        name: 'Gibraltar'
    },
    GL: {
        code: '299',
        name: 'Greenland'
    },
    GM: {
        code: '220',
        name: 'Gambia'
    },
    GN: {
        code: '224',
        name: 'Guinea'
    },
    GP: {
        code: '590',
        name: 'Guadeloupe'
    },
    GQ: {
        code: '240',
        name: 'Equatorial Guinea'
    },
    GR: {
        code: '30',
        name: 'Greece'
    },
    GT: {
        code: '502',
        name: 'Guatemala'
    },
    GU: {
        code: '1671',
        name: 'Guam'
    },
    GW: {
        code: '245',
        name: 'Guinea-Bissau'
    },
    GY: {
        code: '592',
        name: 'Guyana'
    },
    HK: {
        code: '852',
        name: 'Hong Kong'
    },
    HN: {
        code: '504',
        name: 'Honduras'
    },
    HR: {
        code: '385',
        name: 'Croatia'
    },
    HT: {
        code: '509',
        name: 'Haiti'
    },
    HU: {
        code: '36',
        name: 'Hungary'
    },
    IC: {
        code: '3491',
        name: 'Canary Islands'
    },
    ID: {
        code: '62',
        name: 'Indonesia'
    },
    IE: {
        code: '353',
        name: 'Ireland'
    },
    IL: {
        code: '972',
        name: 'Israel'
    },
    IM: {
        code: '44',
        name: 'Isle of Man'
    },
    IN: {
        code: '91',
        name: 'India'
    },
    IQ: {
        code: '964',
        name: 'Iraq'
    },
    IR: {
        code: '98',
        name: 'Iran'
    },
    IS: {
        code: '354',
        name: 'Iceland'
    },
    IT: {
        code: '39',
        name: 'Italy'
    },
    JM: {
        code: '1876',
        name: 'Jamaica'
    },
    JO: {
        code: '962',
        name: 'Jordan'
    },
    JP: {
        code: '81',
        name: 'Japan'
    },
    KE: {
        code: '254',
        name: 'Kenya'
    },
    KG: {
        code: '996',
        name: 'Kyrgyzstan'
    },
    KH: {
        code: '855',
        name: 'Cambodia'
    },
    KI: {
        code: '686',
        name: 'Kiribati'
    },
    KM: {
        code: '269',
        name: 'Comoros'
    },
    KN: {
        code: '1869',
        name: 'St Kitts and Nevis'
    },
    KP: {
        code: '850',
        name: "Korea Dem People's Rep"
    },
    KR: {
        code: '82',
        name: 'Korea Republic of'
    },
    KW: {
        code: '965',
        name: 'Kuwait'
    },
    KY: {
        code: '1345',
        name: 'Cayman Islands'
    },
    LA: {
        code: '856',
        name: 'Laos PDR'
    },
    LB: {
        code: '961',
        name: 'Lebanon'
    },
    LC: {
        code: '1758',
        name: 'St Lucia'
    },
    LI: {
        code: '423',
        name: 'Liechtenstein'
    },
    LK: {
        code: '94',
        name: 'Sri Lanka'
    },
    LR: {
        code: '231',
        name: 'Liberia'
    },
    LS: {
        code: '266',
        name: 'Lesotho'
    },
    LT: {
        code: '370',
        name: 'Lithuania'
    },
    LU: {
        code: '352',
        name: 'Luxembourg'
    },
    LV: {
        code: '371',
        name: 'Latvia'
    },
    LY: {
        code: '218',
        name: 'Libya'
    },
    MA: {
        code: '212',
        name: 'Morocco/Western Sahara'
    },
    MC: {
        code: '377',
        name: 'Monaco'
    },
    MD: {
        code: '373',
        name: 'Moldova'
    },
    ME: {
        code: '382',
        name: 'Montenegro'
    },
    MG: {
        code: '261',
        name: 'Madagascar'
    },
    MH: {
        code: '692',
        name: 'Marshall Islands'
    },
    MK: {
        code: '389',
        name: 'Republic of North Macedonia'
    },
    ML: {
        code: '223',
        name: 'Mali'
    },
    MM: {
        code: '95',
        name: 'Myanmar (Burma)'
    },
    MN: {
        code: '976',
        name: 'Mongolia'
    },
    MO: {
        code: '853',
        name: 'Macau'
    },
    MP: {
        code: '1670',
        name: 'Northern Mariana Islands'
    },
    MQ: {
        code: '596',
        name: 'Martinique'
    },
    MR: {
        code: '222',
        name: 'Mauritania'
    },
    MS: {
        code: '1664',
        name: 'Montserrat'
    },
    MT: {
        code: '356',
        name: 'Malta'
    },
    MU: {
        code: '230',
        name: 'Mauritius'
    },
    MV: {
        code: '960',
        name: 'Maldives'
    },
    MW: {
        code: '265',
        name: 'Malawi'
    },
    MX: {
        code: '52',
        name: 'Mexico'
    },
    MY: {
        code: '60',
        name: 'Malaysia'
    },
    MZ: {
        code: '258',
        name: 'Mozambique'
    },
    NA: {
        code: '264',
        name: 'Namibia'
    },
    NC: {
        code: '687',
        name: 'New Caledonia'
    },
    NE: {
        code: '227',
        name: 'Niger'
    },
    NF: {
        code: '672',
        name: 'Norfolk Island'
    },
    NG: {
        code: '234',
        name: 'Nigeria'
    },
    NI: {
        code: '505',
        name: 'Nicaragua'
    },
    NL: {
        code: '31',
        name: 'Netherlands'
    },
    NO: {
        code: '47',
        name: 'Norway'
    },
    NP: {
        code: '977',
        name: 'Nepal'
    },
    NU: {
        code: '683',
        name: 'Niue'
    },
    NZ: {
        code: '64',
        name: 'New Zealand'
    },
    OM: {
        code: '968',
        name: 'Oman'
    },
    PA: {
        code: '507',
        name: 'Panama'
    },
    PE: {
        code: '51',
        name: 'Peru'
    },
    PF: {
        code: '689',
        name: 'French Polynesia'
    },
    PG: {
        code: '675',
        name: 'Papua New Guinea'
    },
    PH: {
        code: '63',
        name: 'Philippines'
    },
    PK: {
        code: '92',
        name: 'Pakistan'
    },
    PL: {
        code: '48',
        name: 'Poland'
    },
    PM: {
        code: '508',
        name: 'St Pierre and Miquelon'
    },
    PR: {
        code: '1787',
        name: 'Puerto Rico'
    },
    PS: {
        code: '970, 972',
        name: 'Palestinian Territory'
    },
    PT: {
        code: '351',
        name: 'Portugal'
    },
    PW: {
        code: '680',
        name: 'Palau'
    },
    PY: {
        code: '595',
        name: 'Paraguay'
    },
    QA: {
        code: '974',
        name: 'Qatar'
    },
    RE: {
        code: '262',
        name: 'Reunion/Mayotte'
    },
    RO: {
        code: '40',
        name: 'Romania'
    },
    RS: {
        code: '381',
        name: 'Serbia'
    },
    RU: {
        code: '7',
        name: 'Russia/Kazakhstan'
    },
    RW: {
        code: '250',
        name: 'Rwanda'
    },
    SA: {
        code: '966',
        name: 'Saudi Arabia'
    },
    SB: {
        code: '677',
        name: 'Solomon Islands'
    },
    SC: {
        code: '248',
        name: 'Seychelles'
    },
    SD: {
        code: '249',
        name: 'Sudan'
    },
    SE: {
        code: '46',
        name: 'Sweden'
    },
    SG: {
        code: '65',
        name: 'Singapore'
    },
    SI: {
        code: '386',
        name: 'Slovenia'
    },
    SK: {
        code: '421',
        name: 'Slovakia'
    },
    SL: {
        code: '232',
        name: 'Sierra Leone'
    },
    SM: {
        code: '378',
        name: 'San Marino'
    },
    SN: {
        code: '221',
        name: 'Senegal'
    },
    SO: {
        code: '252',
        name: 'Somalia'
    },
    SR: {
        code: '597',
        name: 'Suriname'
    },
    SS: {
        code: '211',
        name: 'South Sudan'
    },
    ST: {
        code: '239',
        name: 'Sao Tome and Principe'
    },
    SV: {
        code: '503',
        name: 'El Salvador'
    },
    SY: {
        code: '963',
        name: 'Syria'
    },
    SZ: {
        code: '268',
        name: 'Swaziland'
    },
    TC: {
        code: '1649',
        name: 'Turks and Caicos Islands'
    },
    TD: {
        code: '235',
        name: 'Chad'
    },
    TG: {
        code: '228',
        name: 'Togo'
    },
    TH: {
        code: '66',
        name: 'Thailand'
    },
    TJ: {
        code: '992',
        name: 'Tajikistan'
    },
    TL: {
        code: '670',
        name: 'East Timor'
    },
    TM: {
        code: '993',
        name: 'Turkmenistan'
    },
    TN: {
        code: '216',
        name: 'Tunisia'
    },
    TO: {
        code: '676',
        name: 'Tonga'
    },
    TR: {
        code: '90',
        name: 'Turkiye'
    },
    TT: {
        code: '1868',
        name: 'Trinidad and Tobago'
    },
    TV: {
        code: '688',
        name: 'Tuvalu'
    },
    TW: {
        code: '886',
        name: 'Taiwan'
    },
    TZ: {
        code: '255',
        name: 'Tanzania'
    },
    UA: {
        code: '380',
        name: 'Ukraine'
    },
    UG: {
        code: '256',
        name: 'Uganda'
    },
    US: {
        code: '1',
        name: 'United States'
    },
    UY: {
        code: '598',
        name: 'Uruguay'
    },
    UZ: {
        code: '998',
        name: 'Uzbekistan'
    },
    VA: {
        code: '379',
        name: 'Vatican City'
    },
    VC: {
        code: '1784',
        name: 'St Vincent Grenadines'
    },
    VE: {
        code: '58',
        name: 'Venezuela'
    },
    VG: {
        code: '1284',
        name: 'Virgin Islands, British'
    },
    VI: {
        code: '1340',
        name: 'Virgin Islands, U.S.'
    },
    VN: {
        code: '84',
        name: 'Vietnam'
    },
    VU: {
        code: '678',
        name: 'Vanuatu'
    },
    WF: {
        code: '681',
        name: 'Wallis and Futuna'
    },
    WS: {
        code: '685',
        name: 'Samoa'
    },
    XK: {
        code: '383',
        name: 'Kosovo'
    },
    YE: {
        code: '967',
        name: 'Yemen'
    },
    ZA: {
        code: '27',
        name: 'South Africa'
    },
    ZM: {
        code: '260',
        name: 'Zambia'
    },
    ZW: {
        code: '263',
        name: 'Zimbabwe'
    }
};

const sendSmsOTP = async (client, { isoCountryCode, phoneNumber })=>{
    const core = getWalletProviderFromWalletAccount.getCore(client);
    const apiClient = getWalletProviderFromWalletAccount.createApiClient(client);
    const phoneCountryCode = supportedCountries[isoCountryCode].code;
    const { verificationUUID } = await apiClient.createSmsVerification({
        environmentId: core.environmentId,
        smsVerificationCreateRequest: {
            isoCountryCode,
            phoneCountryCode,
            phoneNumber
        }
    });
    return getWalletProviderFromWalletAccount.assignClient({
        isoCountryCode,
        phoneCountryCode,
        phoneNumber,
        verificationUUID
    }, client);
};

const verifyOTPForUserSignIn = async (otpVerification, { verificationToken })=>{
    const client = getWalletProviderFromWalletAccount.getClient(otpVerification);
    const core = getWalletProviderFromWalletAccount.getCore(client);
    const apiClient = getWalletProviderFromWalletAccount.createApiClient(client);
    const verifyRequest = {
        verificationToken,
        verificationUUID: otpVerification.verificationUUID
    };
    if (otpVerification.email) {
        return apiClient.signInWithEmailVerification({
            emailVerificationVerifyRequest: verifyRequest,
            environmentId: core.environmentId
        });
    }
    return apiClient.signInWithSmsVerification({
        environmentId: core.environmentId,
        smsVerificationVerifyRequest: verifyRequest
    });
};

const verifyOTPForUserUpdate = async (otpVerification, { verificationToken })=>{
    const client = getWalletProviderFromWalletAccount.getClient(otpVerification);
    const core = getWalletProviderFromWalletAccount.getCore(client);
    const apiClient = getWalletProviderFromWalletAccount.createApiClient(client);
    const verifyRequest = {
        verificationToken,
        verificationUUID: otpVerification.verificationUUID
    };
    if (otpVerification.email) {
        return apiClient.verifyEmailVerification({
            emailVerificationVerifyRequest: verifyRequest,
            environmentId: core.environmentId
        });
    }
    return apiClient.verifySmsVerification({
        environmentId: core.environmentId,
        smsVerificationVerifyRequest: verifyRequest
    });
};

const verifyOTP = async (otpVerification, { verificationToken })=>{
    const client = getWalletProviderFromWalletAccount.getClient(otpVerification);
    const response = client.user ? await verifyOTPForUserUpdate(otpVerification, {
        verificationToken
    }) : await verifyOTPForUserSignIn(otpVerification, {
        verificationToken
    });
    updateAuthFromVerifyResponse(client, response);
    return response.user;
};

const assertWalletAccountSigningAvailability = async (walletAccount)=>{
    const walletProvider = getWalletProviderFromWalletAccount.getWalletProviderFromWalletAccount(walletAccount);
    const { addresses } = await walletProvider.getConnectedAddresses();
    if (!addresses.includes(walletAccount.address)) {
        throw new WalletAccountNotSelectedError({
            expectedAddress: walletAccount.address,
            selectedAddress: addresses[0]
        });
    }
};

/**
 * Emits the `walletAccountsChanged` event.
 */ const emitWalletAccountsChangedEvent = (client)=>{
    const walletAccounts = getWalletAccounts(client);
    const { eventEmitter } = getWalletProviderFromWalletAccount.getCore(client);
    eventEmitter.emit('walletAccountsChanged', walletAccounts);
};

/**
 * Updates the unverified wallet account in the client state.
 */ const setUnverifiedWalletAccount = (client, unverifiedWalletAccountToUpdate)=>{
    const core = getWalletProviderFromWalletAccount.getCore(client);
    const filteredUnverifiedWalletAccounts = core.state.get().unverifiedWalletAccounts.filter((unverifiedWalletAccount)=>unverifiedWalletAccount.id !== unverifiedWalletAccountToUpdate.id);
    core.state.set({
        unverifiedWalletAccounts: [
            ...filteredUnverifiedWalletAccounts,
            unverifiedWalletAccountToUpdate
        ]
    });
};

/**
 * Connects to a wallet provider and returns the connected wallet account.
 *
 * Throws the NoAddressFoundError error in case the request to connect was successful but no
 * address is connected to the dapp.
 */ const connectWithWalletProvider = async (walletProvider)=>{
    const client = getWalletProviderFromWalletAccount.getClient(walletProvider);
    const { addresses: [selectedAddress] } = await walletProvider.connect();
    const currentAddresses = getWalletAccounts(client).map(({ address })=>address);
    /**
   * This error is thrown in case the wallet has no addresses connected
   * to the dapp. Then the error is thrown so the consumer can intruct the
   * user on the next steps.
   */ if (!selectedAddress) {
        throw new NoAddressFoundError();
    }
    const walletAccount = {
        address: selectedAddress,
        chain: walletProvider.chain,
        id: createWalletAccountId(walletProvider.chain, selectedAddress),
        lastSelectedAt: null,
        verifiedCredentialId: null,
        walletProviderKey: walletProvider.key
    };
    /**
   * This error is thrown in case all wallets are already connected to the dapp
   * so the consumer can instruct the user to switch to a different wallet.
   */ if (currentAddresses.includes(selectedAddress)) {
        return walletAccount;
    }
    setUnverifiedWalletAccount(client, walletAccount);
    emitWalletAccountsChangedEvent(client);
    return getWalletProviderFromWalletAccount.assignClient(walletAccount, client);
};

/**
 * Get all available wallet providers.
 */ const getWalletProviders = (client)=>{
    const walletProviderRegistry = getWalletProviderFromWalletAccount.getWalletProviderRegistry(client);
    return walletProviderRegistry.listProviders();
};

/**
 * Get the primary wallet account.
 * The primary wallet account is the one that was last selected by the user.
 * This information is stored in both unverified and verified wallet accounts.
 * This function consolidates this information to determine which wallet was most recently selected.
 */ const getPrimaryWalletAccount = (client)=>{
    const walletAccounts = getWalletAccounts(client);
    const sortedLastSelectedWalletAccounts = walletAccounts.filter((walletAccount)=>Boolean(walletAccount.lastSelectedAt)).sort((a, b)=>b.lastSelectedAt.getTime() - a.lastSelectedAt.getTime());
    if (sortedLastSelectedWalletAccounts.length === 0) {
        return null;
    }
    const [primaryWalletAccount] = sortedLastSelectedWalletAccounts;
    return primaryWalletAccount;
};

/**
 * Make the wallet account provided as the primary wallet account.
 */ const selectPrimaryWalletAccount = async (walletAccount)=>{
    const client = getWalletProviderFromWalletAccount.getClient(walletAccount);
    const core = getWalletProviderFromWalletAccount.getCore(client);
    const currentPrimaryWalletAccount = getPrimaryWalletAccount(client);
    if ((currentPrimaryWalletAccount == null ? void 0 : currentPrimaryWalletAccount.id) === walletAccount.id) {
        return;
    }
    if (walletAccount.verifiedCredentialId) {
        const apiClient = getWalletProviderFromWalletAccount.createApiClient(client);
        const response = await apiClient.selectUserWallet({
            environmentId: core.environmentId,
            userWalletSelectionRequest: {
                walletId: walletAccount.verifiedCredentialId
            }
        });
        updateAuthFromVerifyResponse(client, response);
    } else {
        setUnverifiedWalletAccount(client, getWalletProviderFromWalletAccount._extends({}, walletAccount, {
            lastSelectedAt: new Date()
        }));
    }
};

/**
 * Removes an unverified wallet account from the client's state.
 */ const removeUnverifiedWalletAccount = (client, unverifiedWalletAccount)=>{
    const core = getWalletProviderFromWalletAccount.getCore(client);
    const { unverifiedWalletAccounts } = core.state.get();
    const filteredUnverifiedWalletAccounts = unverifiedWalletAccounts.filter((account)=>account.id !== unverifiedWalletAccount.id);
    core.state.set({
        unverifiedWalletAccounts: filteredUnverifiedWalletAccounts
    });
};

/**
 * Remove a wallet account
 */ const removeWalletAccount = async (walletAccount)=>{
    const client = getWalletProviderFromWalletAccount.getClient(walletAccount);
    const core = getWalletProviderFromWalletAccount.getCore(client);
    const apiClient = getWalletProviderFromWalletAccount.createApiClient(client);
    if (!walletAccount.verifiedCredentialId) {
        removeUnverifiedWalletAccount(client, walletAccount);
        return;
    }
    const response = await apiClient.verifyUnlink({
        environmentId: core.environmentId,
        verifyUnlinkRequest: {
            walletId: walletAccount.verifiedCredentialId
        }
    });
    updateAuthFromVerifyResponse(client, response);
    emitWalletAccountsChangedEvent(client);
};

/**
 * Sign a message with a wallet account
 */ const signMessage = async (walletAccount, { message })=>{
    const walletProvider = getWalletProviderFromWalletAccount.getWalletProviderFromWalletAccount(walletAccount);
    const { signature } = await walletProvider.signMessage({
        message,
        walletAccount
    });
    return {
        signature
    };
};

/**
 * Check if the given value is an Error object
 */ const isError = (error)=>error instanceof Error;

/**
 * Check if the given value is an Error object with a specific code
 */ const isErrorWithCode = (error, code)=>{
    if (!isError(error)) return false;
    return 'code' in error && error.code === code;
};

const isSameAddress = (left, right, chain)=>normalizeAddress(left, chain) === normalizeAddress(right, chain);

/**
 * Verify the ownership of a wallet account and add to the user's verified credentials
 *
 * Throws the WalletAlreadyLinkedToAnotherUserError error in case the wallet is already linked to another user.
 */ const verifyWalletAccount = async (walletAccount)=>{
    if (walletAccount.verifiedCredentialId) {
        throw new WalletAccountAlreadyVerifiedError(walletAccount.address);
    }
    const client = getWalletProviderFromWalletAccount.getClient(walletAccount);
    const core = getWalletProviderFromWalletAccount.getCore(client);
    const apiClient = getWalletProviderFromWalletAccount.createApiClient(client);
    const walletProvider = getWalletProviderFromWalletAccount.getWalletProviderFromWalletAccount(walletAccount);
    const { signedMessage, messageToSign } = await walletProvider.proveOwnership(walletAccount);
    const verifyApiFunction = client.user ? apiClient.verifyLink.bind(apiClient) : apiClient.verify.bind(apiClient);
    try {
        const response = await verifyApiFunction({
            environmentId: core.environmentId,
            verifyRequest: {
                chain: walletAccount.chain,
                messageToSign,
                publicWalletAddress: walletAccount.address,
                signedMessage,
                walletName: walletProvider.key,
                walletProvider: walletProvider.getWalletProviderType()
            }
        });
        /**
     * Remove the now verified wallet account from the unverified wallet accounts
     */ removeUnverifiedWalletAccount(client, walletAccount);
        /**
     * Adds the user with the new wallet verified credential
     * This will add the new verified wallet account to the client`s state
     */ updateAuthFromVerifyResponse(client, response);
        /**
     * Emits the wallet accounts changed event that notifies all listeners
     * that the wallet accounts have changed
     */ emitWalletAccountsChangedEvent(client);
    } catch (error) {
        if (isErrorWithCode(error, 'reassign_wallet_confirm') || isErrorWithCode(error, 'merge_accounts_confirmation')) {
            throw new WalletAlreadyLinkedToAnotherUserError({
                cause: error
            });
        }
        throw error;
    }
    const verifiedWalletAccount = getWalletAccounts(client).find(({ address })=>isSameAddress(address, walletAccount.address, walletAccount.chain));
    getWalletProviderFromWalletAccount.assertDefined(verifiedWalletAccount, 'Verified wallet account not found');
    return verifiedWalletAccount;
};

exports.BaseError = getWalletProviderFromWalletAccount.BaseError;
exports.MfaInvalidOtpError = getWalletProviderFromWalletAccount.MfaInvalidOtpError;
exports.MfaRateLimitedError = getWalletProviderFromWalletAccount.MfaRateLimitedError;
exports.hasExtension = getWalletProviderFromWalletAccount.hasExtension;
exports.offEvent = getWalletProviderFromWalletAccount.offEvent;
exports.onEvent = getWalletProviderFromWalletAccount.onEvent;
exports.onceEvent = getWalletProviderFromWalletAccount.onceEvent;
exports.ClientAlreadyInitializedError = ClientAlreadyInitializedError;
exports.InvalidRedirectStorageStateError = InvalidRedirectStorageStateError;
exports.MissingRedirectStorageStateError = MissingRedirectStorageStateError;
exports.MissingSocialUrlParamError = MissingSocialUrlParamError;
exports.NoAddressFoundError = NoAddressFoundError;
exports.NoPasskeyCredentialsFoundError = NoPasskeyCredentialsFoundError;
exports.NoWebAuthNSupportError = NoWebAuthNSupportError;
exports.UnavailableInServerSideError = UnavailableInServerSideError;
exports.UserNotAuthenticatedError = UserNotAuthenticatedError;
exports.WalletAccountAlreadyVerifiedError = WalletAccountAlreadyVerifiedError;
exports.WalletAccountNotSelectedError = WalletAccountNotSelectedError;
exports.WalletAlreadyLinkedToAnotherUserError = WalletAlreadyLinkedToAnotherUserError;
exports.acknowledgeRecoveryCodes = acknowledgeRecoveryCodes;
exports.assertWalletAccountSigningAvailability = assertWalletAccountSigningAvailability;
exports.authMfaRecoveryCode = authMfaRecoveryCode;
exports.authTotpMfaDevice = authTotpMfaDevice;
exports.authenticatePasskeyMFA = authenticatePasskeyMFA;
exports.completeSocialRedirectSignIn = completeSocialRedirectSignIn;
exports.connectWithWalletProvider = connectWithWalletProvider;
exports.consumeMfaToken = consumeMfaToken;
exports.createDynamicClient = createDynamicClient;
exports.createNewMfaRecoveryCodes = createNewMfaRecoveryCodes;
exports.deleteMfaDevice = deleteMfaDevice;
exports.detectOAuthRedirect = detectOAuthRedirect;
exports.fetchProjectSettings = fetchProjectSettings;
exports.getMfaDevices = getMfaDevices;
exports.getMfaMethods = getMfaMethods;
exports.getMfaRecoveryCodes = getMfaRecoveryCodes;
exports.getMultichainBalances = getMultichainBalances;
exports.getPasskeyAuthenticationOptions = getPasskeyAuthenticationOptions;
exports.getPasskeys = getPasskeys;
exports.getPrimaryWalletAccount = getPrimaryWalletAccount;
exports.getWalletAccounts = getWalletAccounts;
exports.getWalletProviders = getWalletProviders;
exports.initializeClient = initializeClient;
exports.isPendingRecoveryCodesAcknowledgment = isPendingRecoveryCodesAcknowledgment;
exports.isSignedIn = isSignedIn;
exports.isUserMissingMfaAuth = isUserMissingMfaAuth;
exports.logout = logout;
exports.registerPasskey = registerPasskey;
exports.registerTotpMfaDevice = registerTotpMfaDevice;
exports.removeWalletAccount = removeWalletAccount;
exports.selectPrimaryWalletAccount = selectPrimaryWalletAccount;
exports.sendEmailOTP = sendEmailOTP;
exports.sendSmsOTP = sendSmsOTP;
exports.setDefaultMfaDevice = setDefaultMfaDevice;
exports.signInWithPasskey = signInWithPasskey;
exports.signInWithSocialRedirect = signInWithSocialRedirect;
exports.signMessage = signMessage;
exports.updateUser = updateUser;
exports.verifyOTP = verifyOTP;
exports.verifyWalletAccount = verifyWalletAccount;
