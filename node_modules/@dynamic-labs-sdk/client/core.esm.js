import { B as BaseError, g as getCore } from './getWalletProviderFromWalletAccount.esm.js';
export { A as APIError, C as CannotTrackError, p as ClientNotPresentError, q as ClientsDoNotMatchError, I as InvalidStorageSet, V as ValueMustBeDefinedError, W as WalletProviderPriority, a as assertDefined, b as assignClient, c as createApiClient, e as emitEvent, f as getClient, h as getWalletProviderFromWalletAccount, j as getWalletProviderRegistry, n as hasExtension, s as subscribeWithSelector } from './getWalletProviderFromWalletAccount.esm.js';
import { Buffer as Buffer$1 } from 'buffer';
import '@dynamic-labs/sdk-api-core';

class MethodNotImplementedError extends BaseError {
    constructor(methodName){
        super({
            cause: null,
            code: 'method_not_implemented_error',
            docsUrl: null,
            name: 'MethodNotImplementedError',
            shortMessage: `This method is not implemented: ${methodName}`
        });
    }
}

/**
 * Registers an extension to the client.
 *
 * Other extensions can be aware of which extensions are present,
 * and allows creating dependencies between extensions.
 *
 * @param client - The client instance.
 * @param extensionKey - The key of the extension to register.
 * @returns The client instance.
 */ const registerExtension = (client, extensionKey)=>{
    const core = getCore(client);
    core.extensions.add(extensionKey);
};

/**
 * Formats a sign in message to prove ownership of an address.
 */ const formatSignInMessage = async ({ domain, blockchainName, address, uri, chainId, nonce, issuedAt, requestId, statement, resources })=>{
    // This format follows the sign-in with ethereum (SIWE) standard,
    // but we are using it also for non-ethereum wallets for now (eg. Solana)
    // for more context on format and fields, please see:
    // https://docs.login.xyz/general-information/siwe-overview/eip-4361
    const header = `${domain} wants you to sign in with your ${blockchainName} account:`;
    const prefix = [
        header,
        address
    ].join('\n');
    // If there is a statement, we want to add a gap between the prefix and the statement
    // two times '\n', first to move statement to next line and second to add a gap between prefix and statement
    const prefixWithStatementGap = statement ? '\n\n' : '\n';
    const prefixWithStatement = `${[
        prefix,
        statement
    ].join(prefixWithStatementGap)}\n`;
    const suffixFields = [];
    suffixFields.push(`URI: ${uri}`);
    suffixFields.push('Version: 1');
    if (chainId) {
        suffixFields.push(`Chain ID: ${chainId}`);
    }
    suffixFields.push(`Nonce: ${nonce}`);
    suffixFields.push(`Issued At: ${issuedAt}`);
    if (requestId) {
        suffixFields.push(`Request ID: ${requestId}`);
    }
    if (resources == null ? void 0 : resources.length) {
        suffixFields.push(`Resources:${resources.map((resource)=>'\n- ' + resource).join()}`);
    }
    const suffix = suffixFields.join('\n');
    return [
        prefixWithStatement,
        suffix
    ].join('\n');
};

const formatWalletProviderGroupKey = (walletName)=>walletName.replace(/[^a-zA-Z0-9]/g, '').toLowerCase();

/**
 * Format the wallet name and chain to get a wallet provider key.
 */ const formatWalletProviderKey = (walletName, chain)=>{
    const sanitizedWalletName = walletName.replace(/[^a-zA-Z0-9]/g, '').toLowerCase();
    return `${sanitizedWalletName}${chain.toLocaleLowerCase()}`;
};

// eslint-disable-next-line no-restricted-globals
const getBuffer = ()=>Buffer != null ? Buffer : Buffer$1;

const bufferToBase64 = (buf)=>{
    const binstr = Array.prototype.map.call(buf, (ch)=>String.fromCharCode(ch)).join('');
    return getBuffer().from(binstr, 'binary').toString('base64');
};

export { MethodNotImplementedError, bufferToBase64, formatSignInMessage, formatWalletProviderGroupKey, formatWalletProviderKey, getCore, registerExtension };
